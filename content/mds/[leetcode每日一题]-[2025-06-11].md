## 每日一题

!!! warning 菜鸟的日常做题打卡😢

😞: 还没做的题，太难
⭐: 需要再回顾

!!!

### [3403. 从盒子中找出字典序最大的字符串 I(2025-06-04)](https://leetcode.cn/problems/find-the-lexicographically-largest-string-from-the-box-i/description/?envType=daily-question&envId=2025-06-04)

> (字典序越长越大，同样长就比较大小) 贪心，有长的走长的就行。

- 时间复杂度: $ O(n) $·

- 空间复杂度: $ O(n) $

```cpp
class Solution {
public:
    string answerString(string word, int numFriends) {
        int n = word.size();
        // 特殊情况
        if (numFriends == 1) return word;
        // 最长能走的长度
        int targetLen = n - numFriends + 1;
        string ans;
        for (int i = 0; i < n; ++ i) {
            ans = max(ans, word.substr(i, min(targetLen, n - i)));
        }
        return ans;
    }
};
```

### [1061. 按字典序排列最小的等效字符串(2025-06-05)](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/description/?envType=daily-question&envId=2025-06-04)

> 并查集模板题，找每个块中权重最小的值

- 时间复杂度: $ O(n + m) $, $ n $ 为 $ s_1 $的长度, $ m $ 为 $ baseStr $ 的长度

- 空间复杂度: $ O(26) $

```cpp
class Solution {
public:
    // 并查集
    int f[26];

    int find(int x) {
        if (f[x] != x) f[x] = find(f[x]);
        return f[x];
    }

    // 合并且路径压缩
    void merge(int a, int b) {
        int fa = find(a), fb = find(b);
        if (fa == fb) return;
        if (fa < fb) {
            f[fb] = fa;
        } else {
            f[fa] = fb;
        }
    }

    string smallestEquivalentString(string s1, string s2, string baseStr) {
        int n = s1.size();
        for (int i = 0; i < 26; ++ i) f[i] = i;
        for (int i = 0; i < n; ++ i) {
            merge((s1[i] - 'a'), (s2[i] - 'a'));
        }
        string s = "";
        for (int i = 0; i < baseStr.size(); ++ i) {
            s += 'a' + f[find(baseStr[i] - 'a')];
        }
        return s;
    }
};
```

### [2434. 使用机器人打印字典序最小的字符串（2025-06-06）](https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/?envType=daily-question&envId=2025-06-06)

> 题目中的 $ t $ 为先进后出，为栈模式，为了保证字典序，则控制出来的数字最小，使用单调栈来保证。当栈顶（最小）中的数比后缀最小数组中的数还小，则可以出栈（后续没有更小的数了），否则入栈。

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(n) $

```cpp
class Solution {
public:
    string robotWithString(string s) {
        int n = s.size();
        // 模拟栈
        vector<char> stack(n);
        int t = -1;
        // 后缀最小数
        vector<char> suf_min(n, 'z');
        suf_min[n - 1] = min(suf_min[n - 1], s[n - 1]);
        for (int i = n - 1; i >= 1; -- i) {
            suf_min[i - 1] = min(suf_min[i], s[i - 1]);
        }
        string ans = "";
        for (int i = 0; i < n; ++ i) {
            // 栈顶比后缀中最小还要小就出栈
            while (t > -1 && stack[t] <= suf_min[i]) {
                ans += stack[t--];
            }
            stack[++t] = s[i];
        }
        // 清空栈
        while (t > -1) {
            ans += stack[t--];
        }
        return ans;
    }
};
```

### [3170. 删除星号以后字典序最小的字符串（2025-06-07）](https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/?envType=daily-question&envId=2025-06-07)

贪心：删除离 `*` 最近的最小字符，就能让前面的大字符不向前移动

使用栈来保持每次删除的是离当前最近的最小的

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(n) $


```cpp
class Solution {
public:
    string clearStars(string s) {
        int idx = 0;
        int n = s.size();
        vector<int> stack[26];
        for (int i = 0; i < n; ++ i) {
            if (s[i] != '*') {
                stack[s[i] - 'a'].push_back(i);
                continue;
            }
            for (auto& ve : stack) {
                if (!ve.empty()) {
                    s[ve.back()] = '*';
                    ve.pop_back();
                    break;
                }
            }
        }
        erase(s, '*');
        return s;
    }
};
```

### [386. 字典序排数（2025-06-08）](https://leetcode.cn/problems/lexicographical-numbers/description/?envType=daily-question&envId=2025-06-08)

直接dfs扫一遍就行

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(1) $

```cpp
class Solution {
public:
    vector<int> ans;
    vector<int> lexicalOrder(int n) {
        for (int i = 1; i <= 9; ++ i) {
            dfs(i, n);
        }
        return ans;
    }

    void dfs(int num, int limit) {
        if (num > limit) return;
        ans.push_back(num);
        for (int i = 0; i <= 9; ++ i) dfs(num * 10 + i, limit);
    }
};
```

### ⭐[440. 字典序的第K小数字（2025-06-09）](https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order/description/?envType=daily-question&envId=2025-06-09)

在10叉树上做二分，跳跃的是维护的子节点个数


```txt
第一层    1           2        2 - 1 = 1
第二次 10 —— 19    20 21 ...   20 - 10 = 10
```

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(1) $

```cpp
class Solution {
public:
    // 计算 l 到 r 中间的数量
    int dfs(long long l, long long r, int n) { 
        if (l > n) return 0;
        int ans = 0;
        ans += min(r, n + 1LL) - l;
        ans += dfs(l * 10, r * 10, n);
        return ans;
    }

    int findKthNumber(int n, int k) {
        int node = 1;
        k--;
        // 二分
        while (k > 0) {
            // 第 node 层的数量
            int sum = dfs(node, node + 1, n);
            if (k - sum < 0) {
                node *= 10;
                k --;
            } else {
                node += 1;
                k -= sum;
            }
        }
        return node;
    }
};
```

### [3442. 奇偶频次间的最大差值 I（2025-06-10）](https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-i/description/?envType=daily-question&envId=2025-06-10)

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(n) $

```cpp
class Solution {
public:
    int maxDifference(string s) {
        vector<int> cnt(26, 0);
        for (char c : s) { 
            cnt[c - 'a'] += 1;
        }
        int maxn = 0, minn = INT_MAX;
        for (int i : cnt) {
            if (i % 2 == 0 && i != 0) {
                minn = min(minn, i);
            } else {
                maxn = max(maxn, i);
            }
        }
        return maxn - minn;
    }
};
```

### 😞[3445. 奇偶频次间的最大差值 II（2025-06-11）](https://leetcode.cn/problems/maximum-difference-between-even-and-odd-frequency-ii/description/?envType=daily-question&envId=2025-06-11)

- 时间复杂度: $ O() $

- 空间复杂度: $ O() $

```cpp

```



