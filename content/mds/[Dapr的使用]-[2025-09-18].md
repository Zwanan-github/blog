## Dapr的使用

!!! warning

[官方文档](https://docs.dapr.io/)

!!!

### 安装

#### scoop 安装

```powershell
scoop search dapr
```

![](/public/images/2025-09-12-14-22-15-image.png)

```powershell
scoop install dapr-cli
```

### 初始化dapr并启动容器

!!! warning

`dapr` 依赖 `docker` 使用，`docker` 需要先启动

!!!

#### 初始化dapr

可以先在 `docker` 提前找镜像站拉好镜像，免得 `dapr` 在 `init` 的时候拉镜像卡住

- `daprio/dapr:1.15.11`

- `openzipkin/zipkin:latest`

- `redis:6`

```powershell
dapr init
```

### 使用

- 服务调用

- 发布 / 订阅

- 工作流

- 状态管理

- Bingdings

- Actors

- Secret管理

- 配置

- 分布式锁

- 任务

- 互动

#### 服务调用

!!! warning

先起两个服务，我这边随手起一个 `deno_server` ，一个 `springboot_server` 。

!!!

##### 创建服务

`deno_server` 作为服务提供方

- `url` : `http://localhost:8000`

```typescript
import { Hono } from 'hono';

const app = new Hono();

app.get('/', c => {
  return c.json({
    code: 200,
    message: 'deno_server api response!',
    data: null,
  });
});

Deno.serve(app.fetch);
```

`springboot_server` 作为服务调用方

- `url` : `http://localhost:8001`

```kotlin
@RestController
@RequestMapping("/")
class TestController {

    private val DAPR_APP_ID = "deno_server"

    @Autowired
    private lateinit var daprPropertiesConfig: DaprPropertiesConfig

    @GetMapping("/get-deno-data")
    fun getDenoData(): Mono<Result> {
        // 使用 Reactor Netty 的 HttpClient 进行异步 HTTP 请求
        val client = HttpClient.create()
        val responseSingle = client.headers { headers -> headers.set("dapr-app-id", DAPR_APP_ID) }
            .get().uri(daprPropertiesConfig.daprHttpUrl)
            .responseSingle { response, bytes ->
                if (response.status().code() == 200) {
                    bytes.asString().map { body ->
                        val mapper = com.fasterxml.jackson.module.kotlin.jacksonObjectMapper()
                        mapper.readValue(body, Result::class.java)
                    }
                } else {
                    Mono.error(RuntimeException("Failed to fetch data from Deno server"))
                }
            }.map { it -> Result.success("Fetched data successfully", it) }
        return responseSingle
    }
}
```

!!! warning 重要

编写 `dapr.yaml`

- `dapr.yaml` 模板

  ```yaml
  version: 1
  common: # 可选部分，用于跨应用共享变量
    resourcesPath: ./app/components # 任何要跨应用共享的 dapr 资源
    env: # 任何跨应用共享的环境变量
      DEBUG: true
  apps:
    - appID: webapp # 可选
      appDirPath: .dapr/webapp/ # 必需
      resourcesPath: .dapr/resources # 已弃用
      resourcesPaths: .dapr/resources # 逗号分隔的资源路径。（可选）可以按约定保留为默认值。
      appChannelAddress: 127.0.0.1 # 应用监听的网络地址。（可选）可以按约定保留为默认值。
      configFilePath: .dapr/config.yaml # （可选）也可以按约定为默认值，如果未找到文件则忽略。
      appProtocol: http
      appPort: 8080
      appHealthCheckPath: '/healthz'
      command: ['python3', 'app.py']
      appLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 fileAndConsole。
      daprdLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 file。
    - appID: backend # 可选
      appDirPath: .dapr/backend/ # 必需
      appProtocol: grpc
      appPort: 3000
      unixDomainSocket: '/tmp/test-socket'
      env:
        DEBUG: false
      command: ['./backend']
  ```

!!!

```yaml
version: 1
apps:
  - appID: deno_server
    appDirPath: ./deno_server # deno_server应用的执行位置
    appPort: 8000 # 监听服务的端口
    daprHTTPPort: 8080 # dapr提供的http调用的port，通过dapr提供的port调用其他服务
    command: ['deno', 'run', 'start']
  - appID: springboot_server
    appDirPath: ./springboot_server/target
    appPort: 8001 # 监听服务的端口
    daprHTTPPort: 8081
```

##### 调用

可以直接使用 `dapr` 提供的 `daprHttpPort` 调用对应的服务，需要**带上** `dapr-app-id`。

- 直接调用 `deno_server`

![](/public/images/2025-09-12-17-14-32-image.png)

- 从 `springboot_server` 调用 `deno_server`

![](/public/images/2025-09-12-17-13-42-image.png)

#### 发布订阅

!!! warning 注意！

不要用 `kotlin` 写了, 序列化会出问题，**改了一天的痛**, 全改成 `java` 写的了

先随手起三个服务 `shop_server` 、`order_server` 、`account_server`

!!!

##### 创建服务

`order_server` 订单服务订阅方， 订阅 `orderCreate` 事件

- `url`: `http://localhost:8010`

```java
@RequestMapping("/order")
@RestController
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Data
    @Accessors(chain = true)
    @AllArgsConstructor
    static class ResultEntity {
        Integer code; String message; Object data;
    }

    @Data
    @Accessors(chain = true)
    @AllArgsConstructor
    static class Order{
        String orderId; String name;
    }

    @Data
    static class Param {
        Order data;
    }

    @PostMapping(path = "/create", consumes = MediaType.ALL_VALUE)
    public ResultEntity createOrder(@RequestBody Param param) {
        logger.info("order created success, orderId:" + param.getData().getOrderId() + ", orderName: " + param.getData().getName());
        return new ResultEntity(200, "Order created successfully", "order created success, orderId:" + param.getData().getOrderId() + ", orderName: " + param.getData().getName());
    }
}
```

`account_server` 账户服务订阅方， 订阅 `pay` 事件

- `url`: `http://localhost:8020`

```typescript
import { Hono } from 'hono';
const app = new Hono();

app.post('/account/pay', c => {
  console.log('Account Pay Success');
  return c.json({
    message: 'Account Pay Success',
  });
});

Deno.serve(
  {
    port: 8020,
  },
  app.fetch
);
```

`shop_server` 购物服务发布方， 发布 `orderCreate` 和 `pay` 事件

- `url`: `http://localhost:8000`

> `paymentsEvent` 和 `orderCreateEvent` 函数，分别用于发布 `pay` 和 `orderCreate` 事件，在后面`发布/订阅`介绍

```typescript
import { Hono } from 'hono';

const app = new Hono();

app.get('/shop/buy', async c => {
  const name = c.req.query('name') || 'unknown';
  const paymentRes = await paymentsEvent();
  if (!paymentRes.ok) {
    return c.json(
      {
        message: 'failed to publish payment event' + (await paymentRes.text()),
      },
      500
    );
  }
  const orderCreateRes = await createOrderEvent(name);
  if (!orderCreateRes.ok) {
    return c.json(
      {
        message:
          'failed to publish orderCreate event' + (await orderCreateRes.text()),
      },
      500
    );
  }
  console.log(`buy something named: ${name}`);
  return c.json({
    message: `buy ${name} success and orderCreate event published`,
  });
});

Deno.serve(
  {
    port: 8000,
  },
  app.fetch
);
```

##### 发布/订阅的实现

###### 先创建pubsub

位于 `components/` 创建 `pubsub.yaml` 文件

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: shop_order_pubsub # 定义的pubsub组件名(pubsubname)
spec:
  type: pubsub.redis
  version: v1
  metadata:
    - name: redisHost
      value: localhost:6379
    - name: redisPassword
      value: ''
```

- `pubsub` 组件需要注册给每个服务，这里使用一个 `dapr.yaml` 运行多个组件

```yaml
version: 1
common:
  resourcesPath: ./components/ # 共享资源给运行应用
apps:
  - appID: shop-server
    appDirPath: ./shop_server/
    appPort: 8000
    daprHTTPPort: 9000
    command: ['deno', 'run', 'start']
  - appID: order-server
    appDirPath: ./order_server/target/
    appPort: 8010
    daprHTTPPort: 9010
  - appID: account-server
    appDirPath: ./account_server/
    appPort: 8020
    daprHTTPPort: 9020
    command: ['deno', 'run', 'start']
```

###### 订阅的三种方式

> 此处只介绍两种方式： **声明式** 和 **编码方式**

- **声明式**

  声明式一般直接创建 `/components/subscriptions.yaml` 在里面注册订阅就行, 这里把 `account_server` 用声明式注册

  ```yaml
  apiVersion: dapr.io/v2alpha1
  kind: Subscription
  metadata:
    name: shop_order_pubsub
  spec:
    pubsubname: shop_order_pubsub # 使用的 pubsub，一个系统可与创建多个 pubsuub
    topic: pay # topic
    routes:
      default: /account/pay # 导向的路由
  scopes: # 作用域
    - shop-server
    - account-server
  ```

- **编码方式**

  编码模式则是采用重写 `/dapr/subscribe` 请求达到注册,以下是 `SubscriptionController.java`

  ```java
  @RestController
  @RequestMapping("/dapr")
  public class SubscriptionController {

      private static final Logger logger = LoggerFactory.getLogger(SubscriptionController.class);

      @Data
      @AllArgsConstructor
      public static class DaprSubscription {
          private String pubsubname;
          private String topic;
          private String route;
      }

      @GetMapping(value = "/subscribe", produces = "application/json")
      public List<DaprSubscription> subscribe() {
          DaprSubscription daprSubscription = new DaprSubscription(
                  "shop_order_pubsub",
                  "orderCreate",
                  "/order/create"
          );
          logger.info("Subscribed to Pubsubname {} and topic {}", "shop_order_pubsub", "orderCreate");
          return Collections.singletonList(daprSubscription);
      }
  }
  ```

###### 发布的两种方式

> 发布一般有两种方式： **Http方式**、**SDK**方式,这里采用 **Http方式**实现

!!! warning Http 模板

```ts
http://localhost:<daprHttpPort>/v1.0/publish/<pubsubname>/<topic>
```

!!!

`paymentsEvent`: **发布** `account_server` 服务的 `/pay`

```typescript
const paymentsEvent = async () => {
  return await fetch(
    'http://localhost:9000/v1.0/publish/shop_order_pubsub/pay',
    {
      headers: {
        'Content-Type': 'application/json',
      },
      method: 'POST',
    }
  );
};
```

`createOrderEvent`: **发布** `order_server` 服务的 `/orderCreate`

```typescript
const createOrderEvent = async (name: string) => {
  return await fetch(
    'http://localhost:9000/v1.0/publish/shop_order_pubsub/orderCreate',
    {
      headers: {
        'Content-Type': 'application/json',
      },
      method: 'POST',
      body: JSON.stringify({
        orderId: crypto.randomUUID(),
        name: name,
      }),
    }
  );
};
```

##### 调用

###### 调用图

![](/public/images/2025-09-15-23-18-11-image.png)

###### 测试

```powershell
curl 'http://localhost:8000/shop/buy?name=apple'
```

![](/public/images/2025-09-15-23-25-16-image.png)

`order_server` 日志

![](/public/images/2025-09-15-23-26-05-image.png)

`account_server` 日志

![](/public/images/2025-09-15-23-26-53-image.png)

#### 工作流编排

本文使用 `Dapr` 的 `SDK` 创建工作流, 分为下面几个模块：

- `order_processor`: 订单处理
- `payment_server`: 支付服务
- `inventory_server`: 库存服务
- `notify_server`: 通知服务

要完成一笔完整的订单，需要完成下面几个步骤：

1. 检查库存

2. 支付

3. 修改库存

4. 完成订单

那么我们的工作流如图所示：
![2025-09-18-14-13-00-image.png](/public/images/2025-09-18-14-13-00-image.png)

##### 创建服务

`payment_server`: 提供一个 `/payment` 接口表支付

- `url`: `http://localhost:8010/payment`

```typescript
import { Hono } from 'hono';

const app = new Hono();

// 支付
app.post('/payment', c => {
  // 处理支付逻辑
  console.log('Payment received at:', new Date().getTime());
  return c.json({ message: '/payment successful!' });
});

Deno.serve(
  {
    port: 8010,
  },
  app.fetch
);
```

`inventory_server`: 提供检查库存 `/inventory/verify` 接口和修改库存 `/inventory/update` 接口

- `url`: `http://localhost:8020`

```typescript
import { Hono } from 'hono';

const app = new Hono();

// 库存验证
app.post('/inventory/verify', c => {
  // 库存验证
  console.log('Inventory verify at:', new Date().getTime());
  return c.json({ message: '/inventory/verify successful!' });
});

// 库存验证
app.post('/inventory/update', c => {
  // 库存验证
  console.log('Inventory update at:', new Date().getTime());
  return c.json({ message: '/inventory/update successful!' });
});

Deno.serve(
  {
    port: 8020,
  },
  app.fetch
);
```

`notify_server`: 提供通知服务的接口 `/notify`

- `url`: `http://localhost:8030`

```typescript
import { Hono } from 'hono';

const app = new Hono();

type Param = {
  message: string;
};

// 通知服务
app.post('/notify', c => {
  // 库存验证
  // 获取 message
  const param = c.req.json();
  param.then((param: Param) => {
    console.log('Notify message:', param.message, new Date().getTime());
  });
  return c.json({ message: '/notify successful!' });
});

Deno.serve(
  {
    port: 8030,
  },
  app.fetch
);
```

`order_processor`: 编排和执行订单工作

##### 编写工作流的活动Activity:

!!! warning

`Activity` : 采用的方式都是 `服务调用`，第一个 demo 就是

!!!

`InventoryVerifyActivity`: 用来调用 `inventory_server` 的服务，检查库存

```java
public class InventoryVerifyActivity implements WorkflowActivity {

    private static final HttpClient httpClient = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .connectTimeout(Duration.ofSeconds(10))
            .build();
    private static final String DAPR_HTTP_PORT = System.getenv().getOrDefault("DAPR_HTTP_PORT", "9000");

    @Override
    public Object run(WorkflowActivityContext workflowActivityContext) {
        // 远程调用库存服务，验证库存
        String dapr_url = "http://localhost:" + DAPR_HTTP_PORT + "/inventory/verify";
        HttpRequest request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(""))
                .uri(URI.create(dapr_url))
                .header("Content-Type", "application/json")
                .header("dapr-app-id", "inventory-service")
                .build();
        try {
            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            if (send.statusCode() == 200) {
                return true;
            } else {
                return false;
            }

        } catch (IOException | InterruptedException e) {
            return false;
        }
    }
}
```

`PaymentActivity`: 用来调用 `payment_server` 的服务，完成支付

```java
public class PaymentActivity implements WorkflowActivity {
    private static final HttpClient httpClient = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .connectTimeout(Duration.ofSeconds(10))
            .build();
    private static final String DAPR_HTTP_PORT = System.getenv().getOrDefault("DAPR_HTTP_PORT", "9000");

    @Override
    public Object run(WorkflowActivityContext workflowActivityContext) {
        // 远程调用库存服务，验证库存
        String dapr_url = "http://localhost:" + DAPR_HTTP_PORT + "/payment";
        HttpRequest request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(""))
                .uri(URI.create(dapr_url))
                .header("Content-Type", "application/json")
                .header("dapr-app-id", "payment-service")
                .build();
        try {
            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            if (send.statusCode() == 200) {
                return true;
            } else {
                return false;
            }

        } catch (IOException | InterruptedException e) {
            return false;
        }
    }
}
```

`InventoryUpdateActivity`: 用来调用 `inventory_server` 的服务，更新库存

```java
public class InventoryUpdateActivity implements WorkflowActivity {
    private static final HttpClient httpClient = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .connectTimeout(Duration.ofSeconds(10))
            .build();
    private static final String DAPR_HTTP_PORT = System.getenv().getOrDefault("DAPR_HTTP_PORT", "9000");
    @Override
    public Object run(WorkflowActivityContext workflowActivityContext) {
        // 远程调用库存服务，验证库存
        String dapr_url = "http://localhost:" + DAPR_HTTP_PORT + "/inventory/update";
        HttpRequest request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(""))
                .uri(URI.create(dapr_url))
                .header("Content-Type", "application/json")
                .header("dapr-app-id", "inventory-service")
                .build();
        try {
            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            if (send.statusCode() == 200) {
                return true;
            } else {
                return false;
            }
        } catch (IOException | InterruptedException e) {
            return false;
        }
    }
}
```

`NotifyActivity`: 用来调用`notify_server` 的服务，通知功能

```java
public class NotifyActivity implements WorkflowActivity {
    private static final HttpClient httpClient = HttpClient.newBuilder()
            .version(HttpClient.Version.HTTP_2)
            .connectTimeout(Duration.ofSeconds(10))
            .build();
    private static final String DAPR_HTTP_PORT = System.getenv().getOrDefault("DAPR_HTTP_PORT", "9000");

    @Override
    public Object run(WorkflowActivityContext workflowActivityContext) {
        String input = workflowActivityContext.getInput(String.class);
        // 远程调用库存服务，验证库存
        String dapr_url = "http://localhost:" + DAPR_HTTP_PORT + "/notify";
        HttpRequest request = HttpRequest.newBuilder()
                // json 格式传递
                .POST(HttpRequest.BodyPublishers.ofString("{\"message\":\"" + input + "\"}"))
                .uri(URI.create(dapr_url))
                .header("Content-Type", "application/json")
                .header("dapr-app-id", "notify-service")
                .build();
        try {
            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            if (send.statusCode() == 200) {
                return true;
            } else {
                return false;
            }

        } catch (IOException | InterruptedException e) {
            return false;
        }
    }
}
```

##### 注册活动和创建工作流

###### 创建工作流

`OrderProcessWorkflow`: 每个工作流都需要实现 `io.dapr.workflows.Workflow` 的 `create` 方法, 在 `create` 方法中去做编排的任务。使用 `.await()` 方法来规定执行的顺序

```java
public class OrderProcessWorkflow implements Workflow {
    @Override
    public WorkflowStub create() {

        return ctx -> {
            // 检查库存开始
            Boolean inventoryVerify = ctx.callActivity(InventoryVerifyActivity.class.getName(), Boolean.class).await();
            if (!inventoryVerify) {
                ctx.callActivity(NotifyActivity.class.getName(), "Inventory insufficient, order failed").await();
                ctx.complete("Order failed due to insufficient inventory.");
                return;
            }
            // 支付开始
            Boolean payment = ctx.callActivity(PaymentActivity.class.getName(), Boolean.class).await();
            if (!payment) {
                ctx.callActivity(NotifyActivity.class.getName(), "Payment failed, order failed").await();
                ctx.complete("Order failed due to payment failure.");
                return;
            }
            // 更新库存开始
            Boolean inventoryUpdate = ctx.callActivity(InventoryUpdateActivity.class.getName(), Boolean.class).await();
            if (!inventoryUpdate) {
                ctx.callActivity(NotifyActivity.class.getName(), "Inventory update failed, order failed").await();
                ctx.complete("Order failed due to inventory update failure.");
                return;
            }
            // 通知系统: 订单处理成功
            ctx.callActivity(NotifyActivity.class.getName(), "Workflow success " + new Date().getTime()).await();
            ctx.complete("Order processed successfully!");
        };
    }
}
```

###### 注册活动和工作流

直接使用 `WorkflowRuntimeBuilder` 来注册就行

```java
// 注册工作流和活动
public static void registerWorkflowAndActivities() {
    WorkflowRuntimeBuilder builder = new WorkflowRuntimeBuilder();


    builder.registerActivity(NotifyActivity.class)
            .registerActivity(InventoryVerifyActivity.class)
            .registerActivity(PaymentActivity.class)
            .registerActivity(InventoryUpdateActivity.class);

    builder.registerWorkflow(OrderProcessWorkflow.class);

    try (WorkflowRuntime runtime = builder.build()) {
        runtime.start(false);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

##### 运行工作流

运行工作流分为以下三步：

- 安排实例

- 等待开始

- 等待结束

```java
public static void main(String[] args) {
    // 先注册工作流和活动
    registerWorkflowAndActivities();
    // 使用 DaprWorkflowClient 调用工作流
    try(DaprWorkflowClient daprWorkflowClient = new DaprWorkflowClient()) {
        // 调用工作流安排一个新的实例
        String instanceId = daprWorkflowClient.scheduleNewWorkflow(OrderProcessWorkflow.class);
        System.out.printf("Scheduled new workflow instance of OrderProcessWorkflow with instance ID: %s%n", instanceId);
        try {
            // 等待工作流实例启动
            daprWorkflowClient.waitForInstanceStart(instanceId, Duration.ofSeconds(10), false);
            System.out.printf("Workflow instance %s started%n", instanceId);
        } catch (TimeoutException e) {
            System.out.printf("Workflow instance %s did not start within 10 seconds%n", instanceId);
            throw new RuntimeException(e);
        }
        try {
            // 等待工作流实例完成
            WorkflowInstanceStatus workflowInstanceStatus = daprWorkflowClient.waitForInstanceCompletion(instanceId, Duration.ofDays(1), true);
            if (workflowInstanceStatus != null) {
                System.out.printf("Workflow instance completed, out is: %s%n",
                        workflowInstanceStatus.getSerializedOutput() + new Date().getTime());
            } else {
                System.out.printf("Workflow instance %s not found%n", instanceId);
            }
        } catch (TimeoutException e) {
            System.out.printf("Workflow instance %s did not complete within 30 seconds%n", instanceId);
            throw new RuntimeException(e);
        }
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
}
```

###### 运行结果

![2025-09-18-16-19-00-image.png](/public/images/2025-09-18-16-19-00-image.png)
