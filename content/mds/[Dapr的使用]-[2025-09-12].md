## Dapr的使用

!!! warning

[官方文档](https://docs.dapr.io/)

!!!

### 安装

#### scoop 安装

```powershell
scoop search dapr
```

![](/public/images/2025-09-12-14-22-15-image.png)

```powershell
scoop install dapr-cli
```

### 初始化dapr并启动容器

!!! warning

`dapr` 依赖 `docker` 使用，`docker` 需要先启动

!!!

#### 初始化dapr

可以先在 `docker` 提前找镜像站拉好镜像，免得 `dapr` 在 `init` 的时候拉镜像卡住

- `daprio/dapr:1.15.11`

- `openzipkin/zipkin:latest`

- `redis:6`

```powershell
dapr init
```

### 使用

- 服务调用

- 发布 / 订阅

- 工作流

- 状态管理

- Bingdings

- Actors

- Secret管理

- 配置

- 分布式锁

- 任务

- 互动

#### 服务调用

!!! warning

先起两个服务，我这边随手起一个 `deno_server` ，一个  `springboot_server` 。

!!!

`deno_server` 作为服务提供方

- `url` : `http://localhost:8000`

```typescript
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => {
  return c.json({
    code: 200,
    message: 'deno_server api response!',
    data: null
  })
})

Deno.serve(app.fetch)

```

`springboot_server` 作为服务调用方

- `url` : `http://localhost:8001`

```kotlin
@RestController
@RequestMapping("/")
class TestController {

    private val DAPR_APP_ID = "deno_server"

    @Autowired
    private lateinit var daprPropertiesConfig: DaprPropertiesConfig

    @GetMapping("/get-deno-data")
    fun getDenoData(): Mono<Result> {
        // 使用 Reactor Netty 的 HttpClient 进行异步 HTTP 请求
        val client = HttpClient.create()
        val responseSingle = client.headers { headers -> headers.set("dapr-app-id", DAPR_APP_ID) }
            .get().uri(daprPropertiesConfig.daprHttpUrl)
            .responseSingle { response, bytes ->
                if (response.status().code() == 200) {
                    bytes.asString().map { body ->
                        val mapper = com.fasterxml.jackson.module.kotlin.jacksonObjectMapper()
                        mapper.readValue(body, Result::class.java)
                    }
                } else {
                    Mono.error(RuntimeException("Failed to fetch data from Deno server"))
                }
            }.map { it -> Result.success("Fetched data successfully", it) }
        return responseSingle
    }
}
```

!!! warning 重要

编写 `dapr.yaml` 

- `dapr.yaml` 模板
  ```yaml
  version: 1
  common: # 可选部分，用于跨应用共享变量
    resourcesPath: ./app/components # 任何要跨应用共享的 dapr 资源
    env:  # 任何跨应用共享的环境变量
      DEBUG: true
  apps:
    - appID: webapp # 可选
      appDirPath: .dapr/webapp/ # 必需
      resourcesPath: .dapr/resources # 已弃用
      resourcesPaths: .dapr/resources # 逗号分隔的资源路径。（可选）可以按约定保留为默认值。
      appChannelAddress: 127.0.0.1 # 应用监听的网络地址。（可选）可以按约定保留为默认值。
      configFilePath: .dapr/config.yaml # （可选）也可以按约定为默认值，如果未找到文件则忽略。
      appProtocol: http
      appPort: 8080
      appHealthCheckPath: "/healthz"
      command: ["python3", "app.py"]
      appLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 fileAndConsole。
      daprdLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 file。
    - appID: backend # 可选
      appDirPath: .dapr/backend/ # 必需
      appProtocol: grpc
      appPort: 3000
      unixDomainSocket: "/tmp/test-socket"
      env:
        DEBUG: false
      command: ["./backend"]
  ```

!!!

```yaml
version: 1
apps:
  - appID: deno_server
    appDirPath: ./deno_server # deno_server应用的执行位置
    appPort: 8000 # 监听服务的端口
    daprHTTPPort: 8080  # dapr提供的http调用url，通过dapr提供的url调用其他服务
    command: ["deno","run", "start"]
  - appID: springboot_server
    appDirPath: ./springboot_server/target
    appPort: 8001 # 监听服务的端口
    daprHTTPPort: 8081
```

**调用**

可以直接使用 `dapr` 提供的 `daprHttpUrl` 调用对应的服务，需要**带上** `dapr-app-id`。

-  直接调用 `deno_server`

![](/public/images/2025-09-12-17-14-32-image.png)

- 从 `springboot_server` 调用 `deno_server` 

![](/public/images/2025-09-12-17-13-42-image.png)

....正在学习中...
