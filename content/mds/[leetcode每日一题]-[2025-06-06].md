## 每日一题

!!! warning

菜鸟的日常做题打卡😢

!!!

### [3403. 从盒子中找出字典序最大的字符串 I(2025-06-04)](https://leetcode.cn/problems/find-the-lexicographically-largest-string-from-the-box-i/description/?envType=daily-question&envId=2025-06-04)

> (字典序越长越大，同样长就比较大小) 贪心，有长的走长的就行。

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(n) $

```cpp
class Solution {
public:
    string answerString(string word, int numFriends) {
        int n = word.size();
        // 特殊情况
        if (numFriends == 1) return word;
        // 最长能走的长度
        int targetLen = n - numFriends + 1;
        string ans;
        for (int i = 0; i < n; ++ i) {
            ans = max(ans, word.substr(i, min(targetLen, n - i)));
        }
        return ans;
    }
};
```

### [1061. 按字典序排列最小的等效字符串(2025-06-05)](https://leetcode.cn/problems/lexicographically-smallest-equivalent-string/description/?envType=daily-question&envId=2025-06-04)

> 并查集模板题，找每个块中权重最小的值

- 时间复杂度: $ O(n + m) $, $ n $ 为 $ s_1 $的长度, $ m $ 为 $ baseStr $ 的长度

- 空间复杂度: $ O(26) $

```cpp
class Solution {
public:
    // 并查集
    int f[26];

    int find(int x) {
        if (f[x] != x) f[x] = find(f[x]);
        return f[x];
    }

    // 合并且路径压缩
    void merge(int a, int b) {
        int fa = find(a), fb = find(b);
        if (fa == fb) return;
        if (fa < fb) {
            f[fb] = fa;
        } else {
            f[fa] = fb;
        }
    }

    string smallestEquivalentString(string s1, string s2, string baseStr) {
        int n = s1.size();
        for (int i = 0; i < 26; ++ i) f[i] = i;
        for (int i = 0; i < n; ++ i) {
            merge((s1[i] - 'a'), (s2[i] - 'a'));
        }
        string s = "";
        for (int i = 0; i < baseStr.size(); ++ i) {
            s += 'a' + f[find(baseStr[i] - 'a')];
        }
        return s;
    }
};
```

### [2434. 使用机器人打印字典序最小的字符串（2025-06-06）](https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/?envType=daily-question&envId=2025-06-06)

> 题目中的 $ t $ 为先进后出，为栈模式，为了保证字典序，则控制出来的数字最小，使用单调栈来保证。当栈顶（最小）中的数比后缀最小数组中的数还小，则可以出栈（后续没有更小的数了），否则入栈。

- 时间复杂度: $ O(n) $

- 空间复杂度: $ O(n) $

```cpp
class Solution {
public:
    string robotWithString(string s) {
        int n = s.size();
        // 模拟栈
        vector<char> stack(n);
        int t = -1;
        // 后缀最小数
        vector<char> suf_min(n, 'z');
        suf_min[n - 1] = min(suf_min[n - 1], s[n - 1]);
        for (int i = n - 1; i >= 1; -- i) {
            suf_min[i - 1] = min(suf_min[i], s[i - 1]);
        }
        string ans = "";
        for (int i = 0; i < n; ++ i) {
            // 栈顶比后缀中最小还要小就出栈
            while (t > -1 && stack[t] <= suf_min[i]) {
                ans += stack[t--];
            }
            stack[++t] = s[i];
        }
        // 清空栈
        while (t > -1) {
            ans += stack[t--];
        }
        return ans;
    }
};
```


