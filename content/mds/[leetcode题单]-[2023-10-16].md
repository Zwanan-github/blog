# é¢˜å•ï¼ˆå³è¾¹çš„æ•°å­—æ˜¯é¢˜ç›®éš¾åº¦ï¼‰

> æ¥æº[çµèŒ¶å±±è‰¾åºœ](https://space.bilibili.com/206214)

## æ»‘çª—é—®é¢˜

### å®šé•¿æ»‘åŠ¨çª—å£ over !!! ğŸ˜Š

<ul>
<li><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank">1456. å®šé•¿å­ä¸²ä¸­å…ƒéŸ³çš„æœ€å¤§æ•°ç›®</a> 1263</li>
<li><a href="https://leetcode.cn/problems/find-the-k-beauty-of-a-number/" target="_blank">2269. æ‰¾åˆ°ä¸€ä¸ªæ•°å­—çš„ K ç¾ä¸½å€¼</a> 1280</li>
<li><a href="https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/" target="_blank">1984. å­¦ç”Ÿåˆ†æ•°çš„æœ€å°å·®å€¼</a> 1306</li>
<li><a href="https://leetcode.cn/problems/maximum-average-subarray-i/" target="_blank">643. å­æ•°ç»„æœ€å¤§å¹³å‡æ•° I</a></li>
<li><a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/" target="_blank">1343. å¤§å°ä¸º K ä¸”å¹³å‡å€¼å¤§äºç­‰äºé˜ˆå€¼çš„å­æ•°ç»„æ•°ç›®</a> 1317</li>
<li><a href="https://leetcode.cn/problems/k-radius-subarray-averages/" target="_blank">2090. åŠå¾„ä¸º k çš„å­æ•°ç»„å¹³å‡å€¼</a> 1358</li>
<li><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/" target="_blank">2379. å¾—åˆ° K ä¸ªé»‘å—çš„æœ€å°‘æ¶‚è‰²æ¬¡æ•°</a> 1360</li>
<li><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/" target="_blank">1052. çˆ±ç”Ÿæ°”çš„ä¹¦åº—è€æ¿</a> 1418</li>
<li><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/" target="_blank">2841. å‡ ä¹å”¯ä¸€å­æ•°ç»„çš„æœ€å¤§å’Œ</a> 1546</li>
<li><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/" target="_blank">2461. é•¿åº¦ä¸º K å­æ•°ç»„ä¸­çš„æœ€å¤§å’Œ</a> 1553</li>
<li><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/" target="_blank">1423. å¯è·å¾—çš„æœ€å¤§ç‚¹æ•°</a> 1574</li>
<li><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/" target="_blank">2134. æœ€å°‘äº¤æ¢æ¬¡æ•°æ¥ç»„åˆæ‰€æœ‰çš„ 1 II</a> 1748</li>
<li><a href="https://leetcode.cn/problems/sliding-subarray-beauty/" target="_blank">2653. æ»‘åŠ¨å­æ•°ç»„çš„ç¾ä¸½å€¼</a> 1786</li>
<li><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank">567. å­—ç¬¦ä¸²çš„æ’åˆ—</a></li>
<li><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank">438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯</a></li>
<li><a href="https://leetcode.cn/problems/find-substring-with-given-hash-value/" target="_blank">2156. æŸ¥æ‰¾ç»™å®šå“ˆå¸Œå€¼çš„å­ä¸²</a> 2063</li>
<li><a href="https://leetcode.cn/problems/moving-average-from-data-stream/" target="_blank">346. æ•°æ®æµä¸­çš„ç§»åŠ¨å¹³å‡å€¼</a>ï¼ˆä¼šå‘˜é¢˜ï¼‰</li>
<li><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/" target="_blank">1100. é•¿åº¦ä¸º K çš„æ— é‡å¤å­—ç¬¦å­ä¸²</a>ï¼ˆä¼šå‘˜é¢˜ï¼‰</li>
</ul>

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚æœ€é•¿/æœ€å¤§ï¼‰å‰© 1 ä¸ª

<ul>
<li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank">3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²</a></li>
<li><a href="https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/" target="_blank">1493. åˆ æ‰ä¸€ä¸ªå…ƒç´ ä»¥åå…¨ä¸º 1 çš„æœ€é•¿å­æ•°ç»„</a> 1423</li>
<li><a href="https://leetcode.cn/problems/fruit-into-baskets/" target="_blank">904. æ°´æœæˆç¯®</a> 1516</li>
<li><a href="https://leetcode.cn/problems/maximum-erasure-value/" target="_blank">1695. åˆ é™¤å­æ•°ç»„çš„æœ€å¤§å¾—åˆ†</a> 1529</li>
<li><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/" target="_blank">2841. å‡ ä¹å”¯ä¸€å­æ•°ç»„çš„æœ€å¤§å’Œ</a> 1546</li>
<li><a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/" target="_blank">2024. è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦</a> 1643</li>
<li><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/" target="_blank">1004. æœ€å¤§è¿ç»­1çš„ä¸ªæ•° III</a> 1656</li>
<li><a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank">1438. ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„</a> 1672</li>
<li><a href="https://leetcode.cn/problems/longest-nice-subarray/" target="_blank">2401. æœ€é•¿ä¼˜é›…å­æ•°ç»„</a> 1750</li>
<li><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/" target="_blank">1658. å°† x å‡åˆ° 0 çš„æœ€å°æ“ä½œæ•°</a> 1817</li>
<li><a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/" target="_blank">1838. æœ€é«˜é¢‘å…ƒç´ çš„é¢‘æ•°</a> 1876</li>
<li><a href="https://leetcode.cn/problems/find-the-longest-equal-subarray/" target="_blank">2831. æ‰¾å‡ºæœ€é•¿ç­‰å€¼å­æ•°ç»„</a> 1976</li>
<li><a href="https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/" target="_blank">2106. æ‘˜æ°´æœ</a> 2062</li>
<li><a href="https://leetcode.cn/problems/maximum-number-of-visible-points/" target="_blank">1610. å¯è§ç‚¹çš„æœ€å¤§æ•°ç›®</a> 2147</li>
<li><a href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. è‡³å¤šåŒ…å«ä¸¤ä¸ªä¸åŒå­—ç¬¦çš„æœ€é•¿å­ä¸²</a>ï¼ˆä¼šå‘˜é¢˜ï¼‰</li>
<li><a href="https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank">340. è‡³å¤šåŒ…å« K ä¸ªä¸åŒå­—ç¬¦çš„æœ€é•¿å­ä¸²</a>ï¼ˆä¼šå‘˜é¢˜ï¼‰</li>
</ul>

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚æœ€çŸ­/æœ€å°ï¼‰over !!! ğŸ˜Š

<ul>
<li><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank">209. é•¿åº¦æœ€å°çš„å­æ•°ç»„</a></li>
<li><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/" target="_blank">1234. æ›¿æ¢å­ä¸²å¾—åˆ°å¹³è¡¡å­—ç¬¦ä¸²</a> 1878</li>
<li><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" target="_blank">1574. åˆ é™¤æœ€çŸ­çš„å­æ•°ç»„ä½¿å‰©ä½™æ•°ç»„æœ‰åº</a> 1932</li>
<li><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank">76. æœ€å°è¦†ç›–å­ä¸²</a></li>
</ul>

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚å­æ•°ç»„ä¸ªæ•°ï¼‰over !!! ğŸ˜Š

<ul>
<li><a href="https://leetcode.cn/problems/count-complete-subarrays-in-an-array/" target="_blank">2799. ç»Ÿè®¡å®Œå…¨å­æ•°ç»„çš„æ•°ç›®</a> 1398</li>
<li><a href="https://leetcode.cn/problems/subarray-product-less-than-k/" target="_blank">713. ä¹˜ç§¯å°äº K çš„å­æ•°ç»„</a></li>
<li><a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/" target="_blank">1358. åŒ…å«æ‰€æœ‰ä¸‰ç§å­—ç¬¦çš„å­å­—ç¬¦ä¸²æ•°ç›®</a> 1646</li>
<li><a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/" target="_blank">2302. ç»Ÿè®¡å¾—åˆ†å°äº K çš„å­æ•°ç»„æ•°ç›®</a> 1808</li>
<li><a href="https://leetcode.cn/problems/count-the-number-of-good-subarrays/" target="_blank">2537. ç»Ÿè®¡å¥½å­æ•°ç»„çš„æ•°ç›®</a> 1892</li>
<li><a href="https://leetcode.cn/problems/continuous-subarrays/" target="_blank">2762. ä¸é—´æ–­å­æ•°ç»„</a> 1940</li>
</ul>

### å¤šæŒ‡é’ˆæ»‘åŠ¨çª—å£

<ul>
<li><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/" target="_blank">930. å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„</a> 1592</li>
<li><a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/" target="_blank">1248. ç»Ÿè®¡ã€Œä¼˜ç¾å­æ•°ç»„ã€</a> 1624</li>
<li><a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/" target="_blank">1712. å°†æ•°ç»„åˆ†æˆä¸‰ä¸ªå­æ•°ç»„çš„æ–¹æ¡ˆæ•°</a> 2079</li>
<li><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/" target="_blank">2444. ç»Ÿè®¡å®šç•Œå­æ•°ç»„çš„æ•°ç›®</a> 2093</li>
<li><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/" target="_blank">992. K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„</a> 2210</li>
</ul></div></div></div>

## äºŒåˆ†ç­”æ¡ˆ

### äºŒåˆ†ç­”æ¡ˆ

<ul>
<li><a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank">1283. ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•°</a> 1542</li>
<li><a href="https://leetcode.cn/problems/minimum-time-to-complete-trips/" target="_blank">2187. å®Œæˆæ—…é€”çš„æœ€å°‘æ—¶é—´</a> 1641</li>
<li><a href="https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/" target="_blank">2226. æ¯ä¸ªå°å­©æœ€å¤šèƒ½åˆ†åˆ°å¤šå°‘ç³–æœ</a> 1646</li>
<li><a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/" target="_blank">1870. å‡†æ—¶åˆ°è¾¾çš„åˆ—è½¦æœ€å°æ—¶é€Ÿ</a> 1676</li>
<li><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/" target="_blank">1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ›</a> 1725</li>
<li><a href="https://leetcode.cn/problems/koko-eating-bananas/" target="_blank">875. çˆ±åƒé¦™è•‰çš„ç‚ç‚</a> 1766</li>
<li><a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/" target="_blank">1898. å¯ç§»é™¤å­—ç¬¦çš„æœ€å¤§æ•°ç›®</a> 1913</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank">1482. åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•°</a> 1946</li>
<li><a href="https://leetcode.cn/problems/furthest-building-you-can-reach/" target="_blank">1642. å¯ä»¥åˆ°è¾¾çš„æœ€è¿œå»ºç­‘</a> 1962</li>
<li><a href="https://leetcode.cn/problems/escape-the-spreading-fire/" target="_blank">2258. é€ƒç¦»ç«ç¾</a> 2347</li>
</ul>

### æœ€å°åŒ–æœ€å¤§å€¼

<ul>
<li><a href="https://leetcode.cn/problems/minimized-maximum-of-products-distributed-to-any-store/" target="_blank">2064. åˆ†é…ç»™å•†åº—çš„æœ€å¤šå•†å“çš„æœ€å°å€¼</a> 1886</li>
<li><a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/" target="_blank">1760. è¢‹å­é‡Œæœ€å°‘æ•°ç›®çš„çƒ</a> 1940</li>
<li><a href="https://leetcode.cn/problems/minimize-maximum-of-array/" target="_blank">2439. æœ€å°åŒ–æ•°ç»„ä¸­çš„æœ€å¤§å€¼</a> 1965</li>
<li><a href="https://leetcode.cn/problems/house-robber-iv/" target="_blank">2560. æ‰“å®¶åŠ«èˆ IV</a> 2081</li>
<li><a href="https://leetcode.cn/problems/swim-in-rising-water/" target="_blank">778. æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³</a> 2097ï¼ˆç›¸å½“äºæœ€å°åŒ–è·¯å¾„æœ€å¤§å€¼ï¼‰</li>
<li><a href="https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/" target="_blank">2616. æœ€å°åŒ–æ•°å¯¹çš„æœ€å¤§å·®å€¼</a> 2155</li>
<li><a href="https://leetcode.cn/problems/minimize-the-maximum-of-two-arrays/" target="_blank">2513. æœ€å°åŒ–ä¸¤ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼</a> 2302</li>
</ul>

### æœ€å¤§åŒ–æœ€å°å€¼

<ul>
<li><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/" target="_blank">1552. ä¸¤çƒä¹‹é—´çš„ç£åŠ›</a> 1920</li>
<li><a href="https://leetcode.cn/problems/maximum-number-of-alloys/" target="_blank">2861. æœ€å¤§åˆé‡‘æ•°</a> 1981</li>
<li><a href="https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/" target="_blank">2517. ç¤¼ç›’çš„æœ€å¤§ç”œèœœåº¦</a> 2021</li>
<li><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid/" target="_blank">2812. æ‰¾å‡ºæœ€å®‰å…¨è·¯å¾„</a> 2154</li>
<li><a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/" target="_blank">2528. æœ€å¤§åŒ–åŸå¸‚çš„æœ€å°ä¾›ç”µç«™æ•°ç›®</a> 2236</li>
</ul>

### ç¬¬ K å°/å¤§ï¼ˆéƒ¨åˆ†é¢˜ç›®ä¹Ÿå¯ä»¥ç”¨å †è§£å†³ï¼‰

<ul>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank">378. æœ‰åºçŸ©é˜µä¸­ç¬¬ K å°çš„å…ƒç´ </a></li>
<li><a href="https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/" target="_blank">373. æŸ¥æ‰¾å’Œæœ€å°çš„ K å¯¹æ•°å­—</a></li>
<li><a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/" target="_blank">719. æ‰¾å‡ºç¬¬ K å°çš„æ•°å¯¹è·ç¦»</a></li>
<li><a href="https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/" target="_blank">1439. æœ‰åºçŸ©é˜µä¸­çš„ç¬¬ k ä¸ªæœ€å°æ•°ç»„å’Œ</a> 2134</li>
<li><a href="https://leetcode.cn/problems/k-th-smallest-prime-fraction/" target="_blank">786. ç¬¬ K ä¸ªæœ€å°çš„ç´ æ•°åˆ†æ•°</a> 2169</li>
<li><a href="https://leetcode.cn/problems/kth-smallest-product-of-two-sorted-arrays/" target="_blank">2040. ä¸¤ä¸ªæœ‰åºæ•°ç»„çš„ç¬¬ K å°ä¹˜ç§¯</a> 2518</li>
<li><a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/" target="_blank">2386. æ‰¾å‡ºæ•°ç»„çš„ç¬¬ K å¤§å’Œ</a> 2648</li>
</ul>

# ç‹ ç‹ åšé¢˜

## æ»‘åŠ¨çª—å£é—®é¢˜

### å®šé•¿æ»‘åŠ¨çª—å£

#### [1456. å®šé•¿å­ä¸²ä¸­å…ƒéŸ³çš„æœ€å¤§æ•°ç›®](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)

```py
class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        vowel = {}
        vowel['a'] = 1
        vowel['e'] = 1
        vowel['i'] = 1
        vowel['o'] = 1
        vowel['u'] = 1
        i, ans, cnt = 0, 0, 0
        for j, x in enumerate(s):
            cnt += 1 if x in vowel else 0
            if j - i + 1 > k:
                cnt -= 1 if s[i] in vowel else 0
                i += 1
            ans = max(ans, cnt)
        return ans
```

#### [2269. æ‰¾åˆ°ä¸€ä¸ªæ•°å­—çš„ K ç¾ä¸½å€¼](https://leetcode.cn/problems/find-the-k-beauty-of-a-number/)

```py
class Solution:
    def divisorSubstrings(self, num: int, k: int) -> int:
        i, ans = 0, 0
        s = str(num)
        for j, x in enumerate(s):
            if j - i + 1 > k:
                i += 1
            if j - i + 1 == k and int(s[i:j + 1]) != 0 and num % int(s[i:j + 1]) == 0:
                ans += 1
        return ans
```

#### [1984. å­¦ç”Ÿåˆ†æ•°çš„æœ€å°å·®å€¼](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)

```py
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        i, ans = 0, inf
        for j, x in enumerate(nums):
            while j - i + 1 > k:
                i += 1
            if j - i + 1 == k:
                ans = min(ans, x - nums[i])
        return ans
```

#### [643. å­æ•°ç»„æœ€å¤§å¹³å‡æ•° I](https://leetcode.cn/problems/maximum-average-subarray-i/)

```py
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        i, ans, cnt = 0, -inf, 0
        for j, x in enumerate(nums):
            cnt += x
            while j - i + 1 > k:
                cnt -= nums[i]
                i += 1
            if j - i + 1 == k:
                ans = max(ans, cnt / k)
        return ans
```

#### [1343. å¤§å°ä¸º K ä¸”å¹³å‡å€¼å¤§äºç­‰äºé˜ˆå€¼çš„å­æ•°ç»„æ•°ç›®](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

```py
class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        i, ans, cnt = 0, 0, 0
        for j, x in enumerate(arr):
            cnt += x
            while j - i + 1 > k:
                cnt -= arr[i]
                i += 1
            if j - i + 1 == k and cnt / k >= threshold:
                ans += 1
        return ans
```

#### [2090. åŠå¾„ä¸º k çš„å­æ•°ç»„å¹³å‡å€¼](https://leetcode.cn/problems/k-radius-subarray-averages/description/)

```py
class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        i, ans, cnt = 0, [-1 for _ in range(n)], 0
        if n < 2 * k + 1:
            return ans
        for j, x in enumerate(nums):
            cnt += x
            if j >= k:
                if j - i + 1 > k * 2 + 1:
                    cnt -= nums[i]
                    i += 1
                if j - i + 1 == k * 2 + 1:
                    ans[(j + i) >> 1] = cnt // (k * 2 + 1)
        return ans
```

#### [2379. å¾—åˆ° K ä¸ªé»‘å—çš„æœ€å°‘æ¶‚è‰²æ¬¡æ•°](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/)

```py
class Solution:
    def minimumRecolors(self, blocks: str, k: int) -> int:
        vis = {}
        vis['W'], vis['B'] = 1, 0
        i, ans, cnt = 0, inf, 0
        for j, x in enumerate(blocks):
            cnt += vis[x]
            if j - i + 1 > k:
                cnt -= vis[blocks[i]]
                i += 1
            if j - i + 1 == k:
                ans = min(ans, cnt)
        return ans
```

#### [1052. çˆ±ç”Ÿæ°”çš„ä¹¦åº—è€æ¿](https://leetcode.cn/problems/grumpy-bookstore-owner/)

> æ±‚æ•°ç»„é‡ŒæŠŠæŸä¸€ä¸ªé•¿åº¦ä¸º minute çš„åŒºé—´éƒ½æ”¹æˆ 0 ä¼šé€ æˆçš„å·®å€¼ï¼ˆå¢é•¿ï¼‰æœ€å¤§ï¼Œåªéœ€è¦ä½¿ç”¨è¿™ä¸ªå·®å€¼åŠ ä¸ŠåŸæœ‰çš„å¤§å°å³å¯

```py
class Solution:
    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:
        i, ans, cnt, max_diff = 0, 0, 0, 0
        for j, x in enumerate(customers):
            cnt += x if grumpy[j] else 0
            ans += 0 if grumpy[j] else x
            while j - i + 1 > minutes:
                cnt -= customers[i] if grumpy[i] else 0
                i += 1
            if j - i + 1 == minutes:
                max_diff = max(max_diff, cnt)
        return ans + max_diff
```

#### [2841. å‡ ä¹å”¯ä¸€å­æ•°ç»„çš„æœ€å¤§å’Œ](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/)

```py
class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        # ä¸€è¾¹æ±‚å”¯ä¸€å­æ•°ç»„æ•°é‡ï¼Œä¸€è¾¹æ±‚æœ€å¤§å€¼
        cnt = defaultdict(int)
        i, ans, s = 0, 0, 0
        for j, x in enumerate(nums):
            cnt[x] = cnt[x] + 1
            s += x
            if j - i + 1 > k:
                cnt[nums[i]] -= 1
                s -= nums[i]
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            if j - i + 1 == k and len(cnt) >= m:
                ans = max(ans, s)
        return ans if ans != 0 else 0
```

#### [2461. é•¿åº¦ä¸º K å­æ•°ç»„ä¸­çš„æœ€å¤§å’Œ](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/)

```py
class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        # ç»´æŠ¤map && å­æ•°ç»„å’Œ
        i, ans, s, cnt = 0, 0, 0, defaultdict(int)
        for j, x in enumerate(nums):
            s += x
            cnt[x] += 1
            if j - i + 1 > k:
                cnt[nums[i]] -= 1
                s -= nums[i]
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            if j - i + 1 == k and len(cnt) == k:
                ans = max(ans, s)
        return ans
```

#### [1423. å¯è·å¾—çš„æœ€å¤§ç‚¹æ•°](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

```py
class Solution:
    def maxScore(self, cardPoints: List[int], k: int) -> int:
        # é˜²æ­¢ç»´æŠ¤ä¸¤ç«¯, ç›´æ¥åç€åš, æ±‚æœ€å°å­æ•°ç»„å’Œ
        sumn, n = sum(cardPoints), len(cardPoints)
        k = n - k
        if k == 0:
            return sumn
        ans, i, cnt = sumn, 0, 0
        for j, x in enumerate(cardPoints):
            cnt += x
            while j - i + 1 > k:
                cnt -= cardPoints[i]
                i += 1
            if j - i + 1 == k:
                ans = min(ans, cnt)
        return sumn - ans
```

#### [2134. æœ€å°‘äº¤æ¢æ¬¡æ•°æ¥ç»„åˆæ‰€æœ‰çš„ 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)

```py
class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        # æ±‚ 1 æœ€é•¿é•¿åº¦
        k = sum(nums)
        nums += nums
        # æ±‚ k èƒ½è¦†ç›–çš„æœ€é•¿çš„ 1 çš„çª—å£
        i, ans, cnt = 0, 0, 0
        for j, x in enumerate(nums):
            cnt += x
            while j -  i + 1 > k:
                cnt -= nums[i]
                i += 1
            if j - i + 1 == k:
                ans = max(ans, cnt)
        return k - ans
```

#### [2653. æ»‘åŠ¨å­æ•°ç»„çš„ç¾ä¸½å€¼](https://leetcode.cn/problems/sliding-subarray-beauty/)

```py
class Solution:
    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:
        # æ±‚æ•°ç»„åŒºé—´æœ€å°å€¼
        n = len(nums)
        i, cnt = 0, defaultdict(int)
        ans = []
        for j, num in enumerate(nums):
            # åˆ¤æ–­çª—å£é•¿åº¦
            cnt[num] += 1
            while j - i + 1 > k:
                cnt[nums[i]] -= 1
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            t = x
            if j - i + 1 == k:
                for a in range(-50, 51):
                    if a in cnt:
                        if cnt[a] >= t:
                            ans.append(min(0, a))
                            break
                        else:
                            t -= cnt[a]
        return ans
```

#### [567. å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.cn/problems/permutation-in-string/)

```py
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        # æ¯ä¸ªçª—å£éƒ½åˆ¤æ–­æ˜¯å¦åŒ…å«æ‰€æœ‰ s1
        i, cnt, n = 0, Counter(), len(s1)
        s = Counter(s1)
        for j, x in enumerate(s2):
            cnt[x] += 1
            while j - i + 1 > n:
                cnt[s2[i]] -= 1
                if cnt[s2[i]] == 0:
                    del cnt[s2[i]]
                i += 1
            if cnt.items() == s.items():
                return True
        return False
```

#### [438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```py
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        k = len(p)
        origin = Counter(p)
        i, ans, cnt = 0, [], Counter()
        for j, x in enumerate(s):
            cnt[x] += 1
            if j - i + 1 > k:
                cnt[s[i]] -= 1
                if cnt[s[i]] == 0:
                    del cnt[s[i]]
                i += 1
            if j - i + 1 == k and origin.items() == cnt.items():
                ans.append(i)
        return ans
```

#### [2156. æŸ¥æ‰¾ç»™å®šå“ˆå¸Œå€¼çš„å­ä¸²](https://leetcode.cn/problems/find-substring-with-given-hash-value/)

```py
class Solution:
    def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:
        nums = [(ord(x) - ord('a') + 1) for x in s]
        n = len(nums)
        i, cnt, ans = n - 1, 0, n - 1
        # ç”±äºæ­£å‘å‡å»å†é™¤å»ä¸ä¸€å®šå¾—åˆ°çš„æ˜¯æ•´æ•°ï¼Œä¼šæœ‰è¯¯å·®
        # åå‘ä¹˜æ³•ä¼šå¥½äº›
        """
        m = power ** (k - 1)% modulo è¿™ä¸€å¥æ‹¿å‡ºæ¥ç®—ï¼Œæˆ‘åœ¨é‡Œé¢ç®—ï¼Œè¶…æ—¶äº†å¥½å¤šæ¬¡ğŸ¥²
        """
        m = power ** (k - 1)% modulo
        for j in range(n - 1, -1, -1):
            if i - j + 1 > k:
                cnt = (cnt - (nums[i] * m) % modulo)
                i -= 1
            cnt = ((cnt * power) % modulo + nums[j] % modulo) % modulo
            if i - j + 1 == k and cnt == hashValue:
                ans = j
        return s[ans:ans + k]
```

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚æœ€é•¿/æœ€å¤§ï¼‰

#### [3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```py
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        i, cnt = 0, defaultdict(int)
        ans = 0
        for j, x in enumerate(s):
            while x in cnt:
                cnt[s[i]] -= 1
                if cnt[s[i]] == 0:
                    del cnt[s[i]]
                i += 1
            cnt[x] += 1
            ans = max(ans, j - i + 1)
        return ans
```

#### [1493. åˆ æ‰ä¸€ä¸ªå…ƒç´ ä»¥åå…¨ä¸º 1 çš„æœ€é•¿å­æ•°ç»„](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

```py
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        i, cnt = 0, defaultdict(int)
        ans = 0
        for j, x in enumerate(nums):
            cnt[x] += 1
            while cnt[1] < j - i:
                cnt[nums[i]] -= 1
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans - 1
```

#### [904. æ°´æœæˆç¯®](https://leetcode.cn/problems/fruit-into-baskets/)

```py
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        i, cnt = 0, defaultdict(int)
        ans = 0
        for j, x in enumerate(fruits):
            cnt[x] += 1
            while len(cnt) > 2:
                cnt[fruits[i]] -= 1
                if cnt[fruits[i]] == 0:
                    del cnt[fruits[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

#### [1695. åˆ é™¤å­æ•°ç»„çš„æœ€å¤§å¾—åˆ†](https://leetcode.cn/problems/maximum-erasure-value/)

```py
class Solution:
    def maximumUniqueSubarray(self, nums: List[int]) -> int:
        cnt = defaultdict(int)
        i, ans, s = 0, 0, 0
        for j, x in enumerate(nums):
            while x in cnt:
                cnt[nums[i]] -= 1
                s -= nums[i]
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            cnt[x] += 1
            s += x
            ans = max(ans, s)
        return ans
```

#### [2841. å‡ ä¹å”¯ä¸€å­æ•°ç»„çš„æœ€å¤§å’Œ](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/)

```py
class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        i, ans, cnt, s = 0, 0, defaultdict(int), 0
        for j, x in enumerate(nums):
            cnt[x] += 1
            s += x
            while j - i + 1 > k:
                cnt[nums[i]] -= 1
                s -= nums[i]
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            if j - i + 1 == k and len(cnt) >= m:
                ans = max(ans, s)
        return ans
```

#### [2024. è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/)

```py
class Solution:
    def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:
        def getAns(s: str) -> int:
            i, ans, cnt, l = 0, 0, Counter(), 0
            for j, x in enumerate(answerKey):
                cnt[x] += 1 if x == s else 0
                while cnt[x] > k:
                    cnt[answerKey[i]] -= 1 if answerKey[i] == s else 0
                    if cnt[answerKey[i]] == 0:
                        del cnt[answerKey[i]]
                    i += 1
                ans = max(ans, j - i + 1)
            return ans
        return max(getAns('T'), getAns('F'))
```

#### [1004. æœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•° III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```py
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        # æ±‚å­˜åœ¨ä¸€ä¸ªæœ€é•¿çš„å­æ•°ç»„ï¼Œå­æ•°ç»„ä¸­æœ€å¤šåªèƒ½æœ‰ k ä¸ª0
        i, ans, cnt = 0, 0, defaultdict(int)
        for j, x in enumerate(nums):
            cnt[x] += 1
            while cnt[0] > k:
                cnt[nums[i]] -= 1
                if cnt[nums[i]] == 0:
                    del cnt[nums[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

#### [1438. ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

```py
from sortedcontainers import SortedList

class Solution:
    def longestSubarray(self, nums: List[int], limit: int) -> int:
        # ä½¿ç”¨æœ‰åºæ•°ç»„, æ’å…¥ log(n)
        i, ans, cnt = 0, 0, SortedList()
        for j, x in enumerate(nums):
            cnt.add(x)
            while cnt[-1] - cnt[0] > limit:
                cnt.remove(nums[i])
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

#### [2401. æœ€é•¿ä¼˜é›…å­æ•°ç»„](https://leetcode.cn/problems/longest-nice-subarray/description/)

> ä½è¿ç®—çš„é›†åˆæ€æƒ³ç»“åˆæ»‘åŠ¨çª—å£
>
> ä½è¿ç®—æŠ€å·§: [æŠ€å·§](https://leetcode.cn/circle/discuss/CaOJ45/)

```py
class Solution:
    def longestNiceSubarray(self, nums: List[int]) -> int:
        # æŒ‰ç…§æŒ‰ä½ä¸å’Œé›†åˆçš„ç‰¹æ€§åš
        # https://leetcode.cn/circle/discuss/CaOJ45/
        # å¦‚æœæ²¡ç”¨äº¤é›†æ‰èƒ½ä¸º0
        i, ans, _or = 0, 0, 0
        for j, x in enumerate(nums):
            while _or & x != 0:
                # åˆ é™¤é›†åˆä¸­çš„å­é›† nums[i]
                _or ^= nums[i]
                i += 1
            # åŠ å…¥é›†åˆ
            _or |= x
            ans = max(ans, j - i + 1)
        return ans
```

#### [1658. å°† x å‡åˆ° 0 çš„æœ€å°æ“ä½œæ•°](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

```py
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        # æ±‚æœ€çŸ­å’Œä¸º x çš„ä¸¤ç«¯å­æ•°ç»„
        # æ±‚æœ€é•¿å’Œä¸º sum - x çš„å­æ•°ç»„
        i, ans, cnt = 0, -1, 0
        x = sum(nums) - x
        if x < 0: return -1
        for j, num in enumerate(nums):
            cnt += num
            while cnt > x:
                cnt -= nums[i]
                i += 1
            if cnt == x:
                ans = max(ans, j - i + 1)
        return (len(nums) - ans) if ans != -1 else -1
```

#### [1838. æœ€é«˜é¢‘å…ƒç´ çš„é¢‘æ•°](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/)

> æœ‰ç‚¹éš¾ï¼Œä¸è¿‡ç¡®å®å¥½é¢˜ ğŸ¥²

- æ’åº + æ»‘åŠ¨çª—å£åšæ³•

ä¸ºäº†ä¿æŒé¢ç§¯å¥½æ±‚, å…ˆè¿›è¡Œæ’åºã€‚
çª—å£æ¯æ¬¡å‘å³è¾¹ç§»åŠ¨, æ•´ä½“æ“ä½œæ¬¡æ•°éƒ½å¾—é‡å¤åŠ ä¸Š $(nums[r] - nums[r - 1]) * (r - l)$, `l`ã€`r`ä¸ºçª—å£å·¦ã€å³è¾¹ç•Œã€‚
çª—å£å·¦è¾¹ç•Œå³ç§»çš„ä¹‹å‰, æ•´ä½“æ“ä½œæ¬¡æ•°å‡å» $nums[r] - nums[l]$, å†å³ç§»

![](/public/images/2023-10-16_09-08-28_185e06db-6e3e-4002-8579-a28c5223a6df.png)

```py
class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        # æ’åº + çª—å£åšæ³•
        n = len(nums)
        nums.sort()
        i, ans, s = 0, 0, 0
        # çµæ´»æ±‚ s
        for j, x in enumerate(nums):
            # æŠŠå‰é¢çš„å·¦å³éƒ½éœ€è¦åŠ ä¸Šçš„å·®å€¼éƒ½ç®—ä¸Š
            s += (j - i) * (x - nums[j - 1])
            while s > k:
                # å‡å»å·®å€¼
                s -= x - nums[i]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```

- æ’åº + å‰ç¼€å’Œ + äºŒåˆ† åšæ³•

![](/public/images/2023-10-16_11-44-07_2f446b83-aee9-4920-bfb1-fb2778963fc8.png)

```py
class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        n = len(nums)
        # æ’åº
        nums.sort()
        # å¯¹æ¯ä¸ªå³è¾¹ç•Œæ‰¾æœ€å·¦è¾¹ç•Œæ»¡è¶³ åŒºé—´æ“ä½œæ•°å’Œ <= k
        left, ans, cnt = 0, 0, 0
        s = [0 for _ in range(n + 1)]
        # å…ˆæ±‚å‰ç¼€å’Œ
        for i in range(1, n + 1):
            s[i] = s[i - 1] + nums[i - 1]
        for right, x in enumerate(nums):
            l, r = 0, right
            while l < r:
                mid = l + r >> 1
                # æ‰¾æœ€å·¦è¾¹
                if x * (right - mid + 1) - (s[right + 1] - s[mid]) > k:
                    l = mid + 1
                else:
                    r = mid
            if x * (right - l + 1) - (s[right + 1] - s[l]) <= k:
                ans = max(ans, right - l + 1)
        return ans
```

#### [2831. æ‰¾å‡ºæœ€é•¿ç­‰å€¼å­æ•°ç»„](https://leetcode.cn/problems/find-the-longest-equal-subarray/)

- æ»‘åŠ¨çª—å£åšæ³•$O(n)$

> å¯¹æ¯ä¸ªå•ç‹¬çš„æ•°å­—è¿›è¡Œæ»‘åŠ¨çª—å£éå†

```py
class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        # é¦–å…ˆæŠŠç›¸åŒçš„æ•°å­—åˆ†ç»„
        n = len(nums)
        idx = [[] for _ in range(n + 1)]
        for i, x in enumerate(nums):
            idx[x].append(i)
        ans = 0
        # éå†æ¯ä¸ªçª—å£
        for i in idx:
            # å½“å‰çª—å£çš„æœ€é•¿çš„è¿ç»­é•¿åº¦
            l = 0
            for r, x in enumerate(i):
                # å½“å‰çª—å£çœŸå®é•¿åº¦ - çª—å£ä¸­ç›¸åŒæ•°å­—çš„é•¿åº¦
                while (x - i[l] + 1) - (r - l + 1) > k:
                    l += 1
                ans = max(ans, r - l + 1)
        return ans
```

- äºŒåˆ†ç­”æ¡ˆåšæ³•$O(nlogn)$

```py
class Solution:
    def longestEqualSubarray(self, nums: List[int], k: int) -> int:
        n = len(nums)
        l, r = 1, n
        # åˆ¤æ–­æ˜¯å¦æœ‰è¿ç»­ m ä¸ªå…ƒç´ ç›¸ç­‰çš„å­æ•°ç»„
        def check(m: int) -> bool:
            i, ans, cnt = 0, 0, defaultdict(int)
            for j, x in enumerate(nums):
                cnt[x] += 1
                # æœ‰ m ä¸ªç›¸åŒ, åˆ™çª—å£é•¿åº¦æœ€å¤§ä¸º k + m
                while j - i + 1 > k + m:
                    cnt[nums[i]] -= 1
                    if cnt[nums[i]] == 0:
                        del cnt[nums[i]]
                    i += 1
                # å¦‚æœå½“å‰æ•°é‡ >= m å³å¯
                if cnt[x] == m:
                    return True
            return False
        # äºŒåˆ†ç­”æ¡ˆ, æŸ¥æ‰¾æœ€å¤§çš„è¿ç»­ç›¸åŒçš„æ•°é‡
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid):
                l = mid
            else:
                r = mid - 1
        return r
```

#### [2106. æ‘˜æ°´æœ](https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps/)

> æ±‚èƒ½èµ°åˆ°çš„æœ€å·¦è¾¹çš„åæ ‡`left`ä¸º`starPos - k`, æœ€å³è¾¹çš„åæ ‡`right`ä¸º`starPos + k`, éå†`right`ä»`starPos - k`åˆ°`starPos + k`, ç„¶åæ ¹æ®æ–¹å‘æ¥åˆ¤æ–­**å¾€å·¦èµ°å†å¾€å³èµ°**å’Œ**å¾€å³èµ°å†å¾€å·¦èµ°**çš„é•¿åº¦å¤Ÿä¸å¤Ÿ
>
> å‡è®¾ä½ç½®ä¸è¶…è¿‡`startPos`çš„æœ€è¿‘æ°´æœåœ¨`fruits[right][0]`, é‚£ä¹ˆå½“`right`å¢åŠ æ—¶, `left`ä¸å¯èƒ½å‡å°‘, æœ‰å•è°ƒæ€§, å› æ­¤å¯ä»¥ç”¨åŒå‘åŒæŒ‡é’ˆï¼ˆæ»‘åŠ¨çª—å£ï¼‰è§£å†³ã€‚
>
> ![](/public/images/2023-10-16_14-14-46_3674f0f2-774f-4ef6-be55-71ae573a6ee0.png)
>
> å½“$frults[right][0] - starPos + frults[right][0] - frults[left][0] > k$æ—¶, è¯´æ˜å…ˆå‘å³å†å‘å·¦çš„**æ­¥æ•°**è¿‡å¤§
>
> å½“$startPos âˆ’ fruits[left][0] + fruits[right][0] âˆ’ fruits[left][0] > k$æ—¶, è¯´æ˜å…ˆå‘å·¦å†å‘å³çš„**æ­¥æ•°**è¿‡å¤§
>
> å½“ä¸Šé¢ä¸¤ä¸ªæ–¹å‘éƒ½ä¸æ»¡è¶³, è¯´æ˜æ˜¯`left`éœ€è¦å¢å¤§äº†

```py
class Solution:
    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:
        # æšä¸¾èƒ½èµ°åˆ°çš„æœ€å·¦è¾¹
        left = -1
        for i, x in enumerate(fruits):
            if x[0] >= startPos - k:
                left = i
                break
        if left == -1:
            return 0
        ans, s = 0, 0
        for right, p in fruits[left:]:
            if right > startPos + k:
                break
            s += p
            """
             åˆ¤æ–­èµ°çš„æ€»è·ç¦»æ˜¯å¦åˆæ³•, æ— è®ºä»€ä¹ˆæ–¹å‘, åªè¦èµ°çš„æœ€å³è¾¹å¢åŠ ,
             æœ€å·¦è¾¹ä¹Ÿåªä¼šå¢åŠ 
            """
            while right * 2 - startPos - fruits[left][0] > k and \
            startPos - fruits[left][0] * 2 + right > k:
                s -= fruits[left][1]
                left += 1
            ans = max(ans, s)
        return ans
```

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚æœ€çŸ­/æœ€å°ï¼‰

#### [209. é•¿åº¦æœ€å°çš„å­æ•°ç»„](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```py
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        i, cnt, ans = 0, 0, 0x3f3f3f3f
        for j, x in enumerate(nums):
            cnt += x
            while cnt >= target:
                ans = min(ans, j - i + 1)
                cnt -= nums[i]
                i += 1
        return ans if ans != 0x3f3f3f3f else 0
```

#### [1234. æ›¿æ¢å­ä¸²å¾—åˆ°å¹³è¡¡å­—ç¬¦ä¸²](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

> éš¾æƒ³å‡ºæ¥, æ±‚æœ€çŸ­çš„çª—å£èƒ½ä¿è¯çª—å£å¤–çš„å­—æ¯æ•°é‡å‡ <= m

```py
class Solution:
    def balancedString(self, s: str) -> int:
        n = len(s)
        m = n // 4
        # æ±‚æœ€çŸ­çš„çª—å£, ä½¿å¾—çª—å£å¤–çš„æ‰€æœ‰å­—æ¯éƒ½èƒ½ <= m
        l, ans, cnt = 0, inf, Counter(s)
        if all(cnt[x] == m for x in "QWER"):
            return 0
        for r, c in enumerate(s):
            # ä¿æŒçª—å£å¤–é¢çš„æ‰€æœ‰çš„éƒ½ä¸è¶…è¿‡m
            cnt[c] -= 1
            while all(cnt[x] <= m for x in "QWER"):
                # æ»¡è¶³å³å¯å¢å¤§å·¦è¾¹ï¼Œå‡å°çª—å£
                ans = min(ans, r - l + 1)
                cnt[s[l]] += 1
                l += 1
        return ans
```

#### [1574. åˆ é™¤æœ€çŸ­çš„å­æ•°ç»„ä½¿å‰©ä½™æ•°ç»„æœ‰åº](https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)

- æ»‘åŠ¨çª—å£åšæ³•$O(n)$

```py
class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        n = len(arr)
        right = n - 1
        while right > 0:
            if arr[right] < arr[right - 1]:
                break
            right -= 1
        if right == 0:
            return 0
        ans = right
        # æšä¸¾æœ€å·¦è¾¹æ¥ç§»åŠ¨åˆ é™¤çª—å£çš„å³è¾¹ç•Œ
        for left, x in enumerate(arr):
            if left != 0 and arr[left] < arr[left - 1]:
                break
            # å³è¾¹ç•Œå¿…é¡»å¤§äºå·¦è¾¹
            while right < n and arr[left] > arr[right]:
                right += 1
            ans = min(ans, right - left - 1)
            left += 1
        return ans
```

- åŒæŒ‡é’ˆäºŒåˆ†åšæ³•$O(nlogn)$

```py
class Solution:
    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:
        # åˆ é™¤å­æ•°ç»„ä½¿å¾—æœ‰åº
        # å°†æ•°ç»„åˆ†æˆä¸‰éƒ¨åˆ†, å·¦ä¸­å³
        # å·¦è¾¹å’Œå³è¾¹ä¸ºé•¿åº¦ [0,n]çš„æœ‰åºå­æ•°ç»„
        # å…ˆæ‰¾å·¦å³çš„èµ·ç‚¹ç§»åŠ¨
        n = len(arr)
        left, right = 0, n - 1
        while left < n - 1:
            if arr[left] > arr[left + 1]:
                break
            left += 1
        while right > 0:
            if arr[right] < arr[right - 1]:
                break
            right -= 1
        if right == 0 or left == n - 1:
            return 0
        ans = min(n - left - 1, right)
        for i in range(left + 1):
            # åœ¨å³è¾¹æ‰¾æœ€é€‚åˆå·¦è¾¹çš„
            # äºŒåˆ†
            l, r = right, n - 1
            while l < r:
                mid = l + r >> 1
                if (arr[mid] < arr[i]):
                    l = mid + 1
                else:
                    r = mid
            # print(i, l, arr[i], arr[l])
            if (arr[l] >= arr[i]):
                ans = min(ans, l - i - 1)
        return ans
```

#### [76. æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/)

> éš¾æƒ³å‡ºæ¥çš„æ»‘åŠ¨çª—å£ï¼Œç”¨ç›®æ ‡ä¸²å’Œçª—å£é‡ŒåŒ…å«ç›®æ ‡ä¸²çš„é•¿åº¦æ¥å½“çª—å£

```py
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        left, ans, cnt = 0, len(s), defaultdict(int)
        for x in t:
            cnt[x] += 1
        l = len(cnt)
        idx = len(s)
        for right, x in enumerate(s):
            if x in t:
                if cnt[x] == 1:
                    l -= 1
                cnt[x] -= 1
            print(left, right, s[left], x, ans, idx, l)
            # å½“å‰çª—å£æ»¡è¶³äº†, å¼€å§‹ç¼©å°èŒƒå›´
            while l <= 0:
                # è·³è¿‡ä¸å½±å“çš„ç‚¹
                while s[left] not in t:
                    left += 1
                if l <= 0 and ans >= right - left + 1:
                    ans = right - left + 1
                    idx = left
                if s[left] in t:
                    if cnt[s[left]] == 0:
                        l += 1
                    cnt[s[left]] += 1
                left += 1
        return s[idx:idx + ans]
```

### ä¸å®šé•¿æ»‘åŠ¨çª—å£ï¼ˆæ±‚å­æ•°ç»„ä¸ªæ•°ï¼‰ over !!! ğŸ˜Š

#### [2799. ç»Ÿè®¡å®Œå…¨å­æ•°ç»„çš„æ•°ç›®](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/)

> æšä¸¾å³ç«¯ç‚¹è®¡ç®—æ¯ä¸ªå³ç«¯ç‚¹å¯ä»¥ç®—è¿›å»çš„æœ€å³è¾¹çš„å·¦ç«¯ç‚¹
>
> $ans += left$ å³å¯

```py
class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        left = ans = 0
        cnt = defaultdict(int)
        n = len(set(nums))
        # æšä¸¾å³ç«¯ç‚¹
        for right, x in enumerate(nums):
            cnt[x] += 1
            while len(cnt) == n:
                cnt[nums[left]] -= 1
                if cnt[nums[left]] == 0:
                    del cnt[nums[left]]
                left += 1
            # ç´¯åŠ å½“å‰å³ç«¯ç‚¹èƒ½æ¥å—çš„å·¦ç«¯ç‚¹ä¸ªæ•°
            ans += left
        return ans
```

#### [713. ä¹˜ç§¯å°äº K çš„å­æ•°ç»„](https://leetcode.cn/problems/subarray-product-less-than-k/)

```py
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        left, ans, mul = 0, 0, 1
        if min(nums) >= k:
            return 0
        for right, x in enumerate(nums):
            mul *= x
            while mul >= k:
                mul //= nums[left]
                left += 1
            # å½“å‰åŒºé—´çš„æ•°çš„ç§ç±»
            ans += right - left + 1
        return ans
```

#### [1358. åŒ…å«æ‰€æœ‰ä¸‰ç§å­—ç¬¦çš„å­å­—ç¬¦ä¸²æ•°ç›®](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)

```py
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        left, ans, cnt = 0, 0, defaultdict(int)
        for right, x in enumerate(s):
            cnt[x] += 1
            while len(cnt) >= 3:
                cnt[s[left]] -= 1
                if cnt[s[left]] == 0:
                    del cnt[s[left]]
                left += 1
            ans += left
        return ans
```

#### [2302. ç»Ÿè®¡å¾—åˆ†å°äº K çš„å­æ•°ç»„æ•°ç›®](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)

```py
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        left = ans = 0
        s = 0
        for right, x in enumerate(nums):
            s = (((s // (right - left)) if right != left else 0) + x) * (right - left + 1)
            while s >= k:
                s = ((s // (right - left + 1)) - nums[left]) * (right - left)
                left += 1
            ans += right - left + 1
        return ans
```

> å¯ä»¥ä¼˜åŒ–è®¡ç®—, ä¸éœ€è¦æ¯æ¬¡éƒ½ç®—å‡ºæ¥å­æ•°ç»„çš„å€¼ï¼Œåªéœ€è¦å’Œå°±è¡Œ

```py
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        left = ans = 0
        s = 0
        for right, x in enumerate(nums):
            s += x
            while s * (right - left + 1) >= k:
                s -= nums[left]
                left += 1
            ans += right - left + 1
        return ans
```

#### [2537. ç»Ÿè®¡å¥½å­æ•°ç»„çš„æ•°ç›®](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)

```py
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        left, ans = 0, 0
        cnt = defaultdict(int)
        gs = 0
        for right, x in enumerate(nums):
            gs += cnt[x]
            cnt[x] += 1
            while gs >= k:
                gs -= cnt[nums[left]] - 1
                cnt[nums[left]] -= 1
                left += 1
            ans += left
        return ans
```

#### [2762. ä¸é—´æ–­å­æ•°ç»„](https://leetcode.cn/problems/continuous-subarrays/)

```py
from sortedcontainers import SortedList
class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        left, ans = 0, 0
        q = SortedList()
        for right, x in enumerate(nums):
            q.add(x)
            while q[-1] - q[0] > 2:
                q.discard(nums[left])
                left += 1
            ans += right - left + 1
        return ans
```

### å¤šæŒ‡é’ˆæ»‘åŠ¨çª—å£

#### [930. å’Œç›¸åŒçš„äºŒå…ƒå­æ•°ç»„](https://leetcode.cn/problems/binary-subarrays-with-sum/)

```py
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        left = left2 = ans = 0
        cnt1 = cnt2 = 0
        for right, x in enumerate(nums):
            cnt1 += x
            cnt2 += x
            # èµ°åˆ° cnt == goal çš„å·¦è¾¹ç•Œ
            while cnt1 > goal and left <= right:
                cnt1 -= nums[left]
                left += 1
            # å·¦è¾¹ç•Œçš„æœ€å³æ¡ä»¶
            while cnt2 >= goal and left2 <= right:
                cnt2 -= nums[left2]
                left2 += 1
            # [left, left2)ä¸ºç¬¦åˆçš„è¾¹ç•Œ
            ans += left2 - left
        return ans
```

#### [1248. ç»Ÿè®¡ã€Œä¼˜ç¾å­æ•°ç»„ã€](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

```py
class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        left = left2 = ans = 0
        cnt = cnt2 = 0
        for right, x in enumerate(nums):
            cnt += x % 2
            cnt2 += x % 2
            while cnt > k and left <= right:
                cnt -= nums[left] % 2
                left += 1
            while cnt2 >= k and left2 <= right:
                cnt2 -= nums[left2] % 2
                left2 += 1
            ans += left2 - left
        return ans
```

#### [1712. å°†æ•°ç»„åˆ†æˆä¸‰ä¸ªå­æ•°ç»„çš„æ–¹æ¡ˆæ•°](https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/)

- åˆ’åˆ†åŒºåŸŸçš„çµæ´»å˜åŒ–

```py
class Solution:
    def waysToSplit(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        MOD = 10**9 + 7
        for i in range(1, n):
            nums[i] += nums[i - 1]
        l, m, r = 0, 1, 1
        # ç¬¬ä¸€æ¡åˆ†ç•Œçº¿æœ€å¤šåˆ° nums[l] * 3 <= nums[n - 1]
        while l < n - 2 and nums[l] * 3 <= nums[n - 1]:
            m = max(m, l + 1)
            # ç¬¬äºŒæ¡çº¿æœ€å·¦
            while (m < n - 1 and nums[m] < nums[l] * 2):
                m += 1
            # ç¬¬äºŒæ¡çº¿æœ€å³è¾¹
            while (r < n - 2 and nums[r + 1] - nums[l] <= nums[n - 1] - nums[r + 1]):
                r += 1
            ans = (ans + r - m + 1) % MOD
            l += 1
        return ans
```

## äºŒåˆ†ç­”æ¡ˆ

### äºŒåˆ†ç­”æ¡ˆ

#### [1283. ä½¿ç»“æœä¸è¶…è¿‡é˜ˆå€¼çš„æœ€å°é™¤æ•°](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/)

```py
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
        l, r = 1, max(nums)
        def check(x: int) -> bool:
            return sum((i // x + 1 if i % x != 0 else i // x ) for i in nums) > threshold
        while l < r:
            mid = l + r >> 1
            if check(mid):
                l = mid + 1
            else:
                r = mid
        return l
```

#### [2187. å®Œæˆæ—…é€”çš„æœ€å°‘æ—¶é—´](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

```py
class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        l, r = 1, max(time) * totalTrips
        def check(x: int) -> bool:
            return sum((x // i) for i in time) < totalTrips
        while l < r:
            mid = l + r >> 1
            if check(mid):
                l = mid + 1
            else:
                r = mid
        return l
```

#### [2226. æ¯ä¸ªå°å­©æœ€å¤šèƒ½åˆ†åˆ°å¤šå°‘ç³–æœ](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/)

```cpp
typedef long long LL;
class Solution {
public:
    int maximumCandies(vector<int>& candies, long long k) {
        LL max_n = *max_element(candies.begin(), candies.end());
        LL l = 1, r = max_n;
        auto check = [&](LL x) {
            // æŠŠæ‰€æœ‰çš„å¤§äº x çš„æ•°åˆ†å‡ºæ¥è‹¥å¹²ä¸ª xï¼Œæ€»æ•°é‡ >= kï¼Œå°±å¯ä»¥
            LL cnt = 0;
            for (auto candy : candies) {
                cnt =  cnt + (LL)(candy / x);
                if (cnt >= k) return true;
            }
            return cnt >= k;
        };
        while (l < r) {
            LL mid = (l + r + 1) >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return check(r) ? r : 0;
    }
};
```

#### [1870. å‡†æ—¶åˆ°è¾¾çš„åˆ—è½¦æœ€å°æ—¶é€Ÿ](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

```cpp
class Solution {
public:
    int minSpeedOnTime(vector<int>& dist, double hour) {
        int n = dist.size();
        auto check = [&](int x){
            double cnt = 0.0;
            for (int i = 0; i < n - 1; ++ i) {
                cnt += (dist[i] - 1) / x + 1;
                if (cnt > hour) {
                    return false;
                }
            }
            cnt += (double)dist.back() / x;
            return cnt <= hour;
        };
        if (n - 1 > hour) return -1;
        int l = 1, r = 10000000;
        while (l < r) {
            int mid = (r + l) >> 1;
            if (!check(mid)) l = mid + 1;
            else r = mid;
        }
        return check(l) ? l : -1;
    }
};
```

#### [1011. åœ¨ D å¤©å†…é€è¾¾åŒ…è£¹çš„èƒ½åŠ›](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/description/)

```cpp
class Solution {
public:
    int shipWithinDays(vector<int>& ws, int days) {
        int sum = accumulate(ws.begin(), ws.end(), 0);
        int l = *max_element(ws.begin(), ws.end()), r = sum;
        auto check = [&](int mid) {
            int sum = 0, cnt = 0;
            for (int i : ws) {
                if (sum + i > mid) {
                    sum = 0;
                    cnt += 1;
                }
                sum += i;
            }
            cnt += (sum > 0);
            return cnt <= days;
        };
        while (l < r) {
            int mid = (l + r) >> 1;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }
        return check(l) ? l : -1;
    }
};
```

#### [875. çˆ±åƒé¦™è•‰çš„ç‚ç‚](https://leetcode.cn/problems/koko-eating-bananas/)

```cpp
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        int l = 1, r = *max_element(piles.begin(), piles.end());
        auto check = [&](int mid) {
            int sum = 0;
            for (int pile : piles)
                // å‘ä¸Šå–æ•´
                sum += (pile - 1) / mid + 1;
            return sum <= h;
        };
        while (l < r) {
            int mid = (l + r) >> 1;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }
        return check(l) ? l : -1;
    }
};
```

#### [1898. å¯ç§»é™¤å­—ç¬¦çš„æœ€å¤§æ•°ç›®](https://leetcode.cn/problems/maximum-number-of-removable-characters/)

```cpp
class Solution {
public:
    int maximumRemovals(string s, string p, vector<int>& removable) {
        int l = 0, r = removable.size();
        auto check = [&](int mid) {
            string temp = s;
            for (int i = 0; i < mid; ++ i)
                temp.replace(removable[i], 1, " ");
            int i = 0, j = 0;
            while (i < s.size() && j < p.size()) {
                if (temp[i] == ' ') ++ i;
                else if (temp[i] == p[j]) ++ i, ++ j;
                else ++ i;
            }
            return j == p.size();
        };
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return check(r) ? r : 0;
    }
};
```

#### [1482. åˆ¶ä½œ m æŸèŠ±æ‰€éœ€çš„æœ€å°‘å¤©æ•°](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/)

```cpp
class Solution {
public:
    int minDays(vector<int>& bloomDay, int m, int k) {
        int l = *min_element(bloomDay.begin(), bloomDay.end()), r = *max_element(bloomDay.begin(), bloomDay.end());
        auto check = [&](int mid){
            int cnt = 0;
            int along = 0, i = 0;
            while (i < bloomDay.size()) {
                if (bloomDay[i] <= mid)
                    ++ along;
                else along = 0;
                if (along >= k) {
                    along = 0;
                    ++ cnt;
                }
                if(cnt >= m) return true;
                ++ i;
            }
            return cnt >= m;
        };
        while (l < r) {
            int mid = (l + r) >> 1;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }
        return check(l) ? l : -1;
    }
};
```

#### [1642. å¯ä»¥åˆ°è¾¾çš„æœ€è¿œå»ºç­‘](https://leetcode.cn/problems/furthest-building-you-can-reach/)

```cpp
class Solution {
public:
    int furthestBuilding(vector<int>& heights, int bricks, int ladders) {
        // å·®åˆ†
        int n = heights.size();
        for (int i = 0; i < n - 1; ++ i)
            if (heights[i] < heights[i + 1]) heights[i] = heights[i + 1] - heights[i];
            else heights[i] = 0;
        auto check = [&](int mid) {
            priority_queue<int, vector<int>, less<int>> heap(heights.begin(), heights.begin() + mid);
            // å…ˆæŠŠå¤§çš„ç”¨æ¢¯å­
            int _ladders = ladders, _bricks = bricks;
            while (!heap.empty() && _ladders --) heap.pop();
            int sum = 0;
            while (!heap.empty()) sum += heap.top(), heap.pop();
            return sum <= _bricks;
        };
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return check(r) ? r : -1;
    }
};
```
