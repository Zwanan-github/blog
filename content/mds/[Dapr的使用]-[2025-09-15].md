## Dapr的使用

!!! warning

[官方文档](https://docs.dapr.io/)

!!!

### 安装

#### scoop 安装

```powershell
scoop search dapr
```

![](/public/images/2025-09-12-14-22-15-image.png)

```powershell
scoop install dapr-cli
```

### 初始化dapr并启动容器

!!! warning

`dapr` 依赖 `docker` 使用，`docker` 需要先启动

!!!

#### 初始化dapr

可以先在 `docker` 提前找镜像站拉好镜像，免得 `dapr` 在 `init` 的时候拉镜像卡住

- `daprio/dapr:1.15.11`

- `openzipkin/zipkin:latest`

- `redis:6`

```powershell
dapr init
```

### 使用

- 服务调用

- 发布 / 订阅

- 工作流

- 状态管理

- Bingdings

- Actors

- Secret管理

- 配置

- 分布式锁

- 任务

- 互动

#### 服务调用

!!! warning

先起两个服务，我这边随手起一个 `deno_server` ，一个  `springboot_server` 。

!!!

##### 创建服务

`deno_server` 作为服务提供方

- `url` : `http://localhost:8000`

```typescript
import { Hono } from 'hono'

const app = new Hono()

app.get('/', (c) => {
  return c.json({
    code: 200,
    message: 'deno_server api response!',
    data: null
  })
})

Deno.serve(app.fetch)
```

`springboot_server` 作为服务调用方

- `url` : `http://localhost:8001`

```kotlin
@RestController
@RequestMapping("/")
class TestController {

    private val DAPR_APP_ID = "deno_server"

    @Autowired
    private lateinit var daprPropertiesConfig: DaprPropertiesConfig

    @GetMapping("/get-deno-data")
    fun getDenoData(): Mono<Result> {
        // 使用 Reactor Netty 的 HttpClient 进行异步 HTTP 请求
        val client = HttpClient.create()
        val responseSingle = client.headers { headers -> headers.set("dapr-app-id", DAPR_APP_ID) }
            .get().uri(daprPropertiesConfig.daprHttpUrl)
            .responseSingle { response, bytes ->
                if (response.status().code() == 200) {
                    bytes.asString().map { body ->
                        val mapper = com.fasterxml.jackson.module.kotlin.jacksonObjectMapper()
                        mapper.readValue(body, Result::class.java)
                    }
                } else {
                    Mono.error(RuntimeException("Failed to fetch data from Deno server"))
                }
            }.map { it -> Result.success("Fetched data successfully", it) }
        return responseSingle
    }
}
```

!!! warning 重要

编写 `dapr.yaml` 

- `dapr.yaml` 模板
  
  ```yaml
  version: 1
  common: # 可选部分，用于跨应用共享变量
    resourcesPath: ./app/components # 任何要跨应用共享的 dapr 资源
    env:  # 任何跨应用共享的环境变量
      DEBUG: true
  apps:
    - appID: webapp # 可选
      appDirPath: .dapr/webapp/ # 必需
      resourcesPath: .dapr/resources # 已弃用
      resourcesPaths: .dapr/resources # 逗号分隔的资源路径。（可选）可以按约定保留为默认值。
      appChannelAddress: 127.0.0.1 # 应用监听的网络地址。（可选）可以按约定保留为默认值。
      configFilePath: .dapr/config.yaml # （可选）也可以按约定为默认值，如果未找到文件则忽略。
      appProtocol: http
      appPort: 8080
      appHealthCheckPath: "/healthz"
      command: ["python3", "app.py"]
      appLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 fileAndConsole。
      daprdLogDestination: file # （可选），可以是 file, console 或 fileAndConsole。默认是 file。
    - appID: backend # 可选
      appDirPath: .dapr/backend/ # 必需
      appProtocol: grpc
      appPort: 3000
      unixDomainSocket: "/tmp/test-socket"
      env:
        DEBUG: false
      command: ["./backend"]
  ```

!!!

```yaml
version: 1
apps:
  - appID: deno_server
    appDirPath: ./deno_server # deno_server应用的执行位置
    appPort: 8000 # 监听服务的端口
    daprHTTPPort: 8080  # dapr提供的http调用的port，通过dapr提供的port调用其他服务
    command: ["deno","run", "start"]
  - appID: springboot_server
    appDirPath: ./springboot_server/target
    appPort: 8001 # 监听服务的端口
    daprHTTPPort: 8081
```

##### 调用

可以直接使用 `dapr` 提供的 `daprHttpPort` 调用对应的服务，需要**带上** `dapr-app-id`。

- 直接调用 `deno_server`

![](/public/images/2025-09-12-17-14-32-image.png)

- 从 `springboot_server` 调用 `deno_server` 

![](/public/images/2025-09-12-17-13-42-image.png)

#### 发布订阅

!!! warning 注意！

不要用 `kotlin` 写了, 序列化会出问题，**改了一天的痛**, 全改成 `java` 写的了

先随手起三个服务 `shop_server` 、`order_server` 、`account_server`

!!!

##### 创建服务

`order_server` 订单服务订阅方， 订阅 `orderCreate` 事件

- `url`: `http://localhost:8010`

```java
@RequestMapping("/order")
@RestController
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    @Data
    @Accessors(chain = true)
    @AllArgsConstructor
    static class ResultEntity {
        Integer code; String message; Object data;
    }

    @Data
    @Accessors(chain = true)
    @AllArgsConstructor
    static class Order{
        String orderId; String name;
    }

    @Data
    static class Param {
        Order data;
    }

    @PostMapping(path = "/create", consumes = MediaType.ALL_VALUE)
    public ResultEntity createOrder(@RequestBody Param param) {
        logger.info("order created success, orderId:" + param.getData().getOrderId() + ", orderName: " + param.getData().getName());
        return new ResultEntity(200, "Order created successfully", "order created success, orderId:" + param.getData().getOrderId() + ", orderName: " + param.getData().getName());
    }
}
```

`account_server` 账户服务订阅方， 订阅 `pay` 事件

- `url`: `http://localhost:8020`

```typescript
import { Hono } from 'hono'
const app = new Hono()

app.post('/account/pay', (c) => {
  console.log('Account Pay Success')
  return c.json({
  message: 'Account Pay Success',
  })
})

Deno.serve({
  port: 8020
},app.fetch)
```

`shop_server` 购物服务发布方， 发布 `orderCreate` 和 `pay` 事件

- `url`: `http://localhost:8000`

> `paymentsEvent` 和 `orderCreateEvent` 函数，分别用于发布 `pay` 和 `orderCreate` 事件，在后面`发布/订阅`介绍 

```typescript
import {Hono} from "hono";

const app = new Hono();

app.get("/shop/buy", async (c) => {
  const name = c.req.query("name") || "unknown";
  const paymentRes = await paymentsEvent();
  if (!paymentRes.ok) {
    return c.json({ message: 'failed to publish payment event' + await paymentRes.text() }, 500);
  }
  const orderCreateRes = await createOrderEvent(name);
  if (!orderCreateRes.ok) {
    return c.json({ message: 'failed to publish orderCreate event' + await orderCreateRes.text() }, 500);
  }
  console.log(`buy something named: ${name}`);
  return c.json({
    message: `buy ${name} success and orderCreate event published`
  });
});

Deno.serve({
  port: 8000
},app.fetch);
```

##### 发布/订阅的实现

###### 先创建pubsub

位于 `components/` 创建 `pubsub.yaml` 文件

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: shop_order_pubsub # 定义的pubsub组件名(pubsubname)
spec:
  type: pubsub.redis
  version: v1
  metadata:
    - name: redisHost
      value: localhost:6379
    - name: redisPassword
      value: ""


```

- `pubsub` 组件需要注册给每个服务，这里使用一个 `dapr.yaml` 运行多个组件

```yaml
version: 1
common:
  resourcesPath: ./components/ # 共享资源给运行应用
apps:
  - appID: shop-server
    appDirPath: ./shop_server/
    appPort: 8000
    daprHTTPPort: 9000
    command: ["deno", "run", "start"]
  - appID: order-server
    appDirPath: ./order_server/target/
    appPort: 8010
    daprHTTPPort: 9010
  - appID: account-server
    appDirPath: ./account_server/
    appPort: 8020
    daprHTTPPort: 9020
    command: [ "deno", "run", "start" ]
```

###### 订阅的三种方式

> 此处只介绍两种方式： **声明式** 和 **编码方式**

- **声明式**
  
  声明式一般直接创建 `/components/subscriptions.yaml` 在里面注册订阅就行, 这里把 `account_server` 用声明式注册
  
  ```yaml
  apiVersion: dapr.io/v2alpha1
  kind: Subscription
  metadata:
    name: shop_order_pubsub
  spec:
    pubsubname: shop_order_pubsub # 使用的 pubsub，一个系统可与创建多个 pubsuub
    topic: pay # topic
    routes:
      default: /account/pay # 导向的路由
  scopes: # 作用域
    - shop-server
    - account-server
  ```

- **编码方式**
  
  编码模式则是采用重写 `/dapr/subscribe` 请求达到注册,以下是 `SubscriptionController.java`
  
  ```java
  @RestController
  @RequestMapping("/dapr")
  public class SubscriptionController {
  
      private static final Logger logger = LoggerFactory.getLogger(SubscriptionController.class);
  
      @Data
      @AllArgsConstructor
      public static class DaprSubscription {
          private String pubsubname;
          private String topic;
          private String route;
      }
  
      @GetMapping(value = "/subscribe", produces = "application/json")
      public List<DaprSubscription> subscribe() {
          DaprSubscription daprSubscription = new DaprSubscription(
                  "shop_order_pubsub",
                  "orderCreate",
                  "/order/create"
          );
          logger.info("Subscribed to Pubsubname {} and topic {}", "shop_order_pubsub", "orderCreate");
          return Collections.singletonList(daprSubscription);
      }
  }
  ```

###### 发布的两种方式

> 发布一般有两种方式： **Http方式**、**SDK**方式,这里采用 **Http方式**实现

!!! warning Http 模板

```ts
http://localhost:<daprHttpPort>/v1.0/publish/<pubsubname>/<topic>
```

!!!

`paymentsEvent`:  **发布** `account_server` 服务的 `/pay` 

```typescript
const paymentsEvent = async () => {
  return await fetch('http://localhost:9000/v1.0/publish/shop_order_pubsub/pay', {
    headers: {
      "Content-Type": "application/json"
    },
    method: 'POST'
  });
}
```

`createOrderEvent`: **发布** `order_server` 服务的 `/orderCreate`

```typescript
const createOrderEvent = async (name: string) => {
  return await fetch('http://localhost:9000/v1.0/publish/shop_order_pubsub/orderCreate', {
    headers: {
      "Content-Type": "application/json"
    },
    method: 'POST',
    body: JSON.stringify({
      "orderId": crypto.randomUUID(),
      "name": name
    })
  });
}
```

##### 调用

###### 调用图

![](/public/images/2025-09-15-23-18-11-image.png)

###### 测试

```powershell
curl 'http://localhost:8000/shop/buy?name=apple'
```

![](/public/images/2025-09-15-23-25-16-image.png)

`order_server` 日志

![](/public/images/2025-09-15-23-26-05-image.png)

`account_server` 日志

![](/public/images/2025-09-15-23-26-53-image.png)
